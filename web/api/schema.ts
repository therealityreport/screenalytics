/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/episodes": {
    /**
     * List Episodes
     * @description List all episodes.
     *
     * Show slugs are normalized to UPPERCASE for consistent display.
     */
    get: operations["list_episodes_episodes_get"];
    /** Create Episode */
    post: operations["create_episode_episodes_post"];
  };
  "/episodes/s3_videos": {
    /** List S3 Videos */
    get: operations["list_s3_videos_episodes_s3_videos_get"];
  };
  "/episodes/s3_shows": {
    /**
     * List S3 Shows
     * @description List all shows available in S3 with episode counts.
     *
     * Show codes are normalized to UPPERCASE and deduplicated case-insensitively.
     */
    get: operations["list_s3_shows_episodes_s3_shows_get"];
  };
  "/episodes/s3_shows/{show}/episodes": {
    /**
     * List S3 Episodes For Show
     * @description List all episodes for a specific show from S3.
     */
    get: operations["list_s3_episodes_for_show_episodes_s3_shows__show__episodes_get"];
  };
  "/episodes/{ep_id}/delete": {
    /** Delete Episode New */
    post: operations["delete_episode_new_episodes__ep_id__delete_post"];
  };
  "/episodes/delete_all": {
    /** Delete All */
    post: operations["delete_all_episodes_delete_all_post"];
  };
  "/episodes/{ep_id}": {
    /** Episode Details */
    get: operations["episode_details_episodes__ep_id__get"];
    /** Delete Episode */
    delete: operations["delete_episode_episodes__ep_id__delete"];
  };
  "/episodes/purge_all": {
    /** Purge All */
    post: operations["purge_all_episodes_purge_all_post"];
  };
  "/episodes/{ep_id}/progress": {
    /** Episode Progress */
    get: operations["episode_progress_episodes__ep_id__progress_get"];
  };
  "/episodes/{ep_id}/status": {
    /** Episode Run Status */
    get: operations["episode_run_status_episodes__ep_id__status_get"];
  };
  "/episodes/{ep_id}/events": {
    /** Episode Events */
    get: operations["episode_events_episodes__ep_id__events_get"];
  };
  "/episodes/upsert_by_id": {
    /** Upsert By Id */
    post: operations["upsert_by_id_episodes_upsert_by_id_post"];
  };
  "/episodes/{ep_id}/assets": {
    /** Presign Episode Assets */
    post: operations["presign_episode_assets_episodes__ep_id__assets_post"];
  };
  "/episodes/{ep_id}/mirror": {
    /** Mirror Episode Video */
    post: operations["mirror_episode_video_episodes__ep_id__mirror_post"];
  };
  "/episodes/{ep_id}/hydrate": {
    /** Hydrate Episode Video */
    post: operations["hydrate_episode_video_episodes__ep_id__hydrate_post"];
  };
  "/episodes/{ep_id}/mirror_artifacts": {
    /**
     * Mirror Episode Artifacts
     * @description Mirror faces/identities artifacts from S3 to local storage.
     *
     * This endpoint downloads manifest files (faces.jsonl, identities.json) from S3
     * to the local file system, enabling clustering operations on machines that
     * don't have direct S3 access or need local copies.
     *
     * Unlike /mirror which only mirrors the video, this mirrors the pipeline artifacts.
     */
    post: operations["mirror_episode_artifacts_episodes__ep_id__mirror_artifacts_post"];
  };
  "/episodes/{ep_id}/refresh_similarity": {
    /**
     * Refresh Similarity Values
     * @description Recompute all similarity scores for the episode.
     *
     * This regenerates track representatives, cluster centroids, updates
     * all similarity scores, and refreshes suggestions for unassigned clusters.
     *
     * Returns detailed step-by-step progress log with stats.
     */
    post: operations["refresh_similarity_values_episodes__ep_id__refresh_similarity_post"];
  };
  "/episodes/{ep_id}/refresh_similarity_async": {
    /**
     * Refresh Similarity Async
     * @description Enqueue similarity refresh as background job (non-blocking).
     *
     * Execution Mode:
     *     - execution_mode="redis" (default): Enqueues job via Celery, returns 202 with job_id
     *     - execution_mode="local": Runs job synchronously in-process, returns result when done
     *
     * If Celery/Redis are unavailable in redis mode, returns an error.
     */
    post: operations["refresh_similarity_async_episodes__ep_id__refresh_similarity_async_post"];
  };
  "/episodes/{ep_id}/recover_noise_tracks/preview": {
    /**
     * Recover Noise Tracks Preview
     * @description Preview what would change if recovery were run (without making changes).
     *
     * Returns counts of single-frame tracks and estimated recoverable tracks.
     */
    get: operations["recover_noise_tracks_preview_episodes__ep_id__recover_noise_tracks_preview_get"];
  };
  "/episodes/{ep_id}/recover_noise_tracks": {
    /**
     * Recover Noise Tracks
     * @description Recover single-frame tracks by finding similar faces in adjacent frames.
     *
     * For each track that has only 1 face (single-frame track):
     * 1. Searches ±frame_window frames for similar faces (cosine similarity >= min_similarity)
     * 2. Merges matching faces into the single-frame track
     * 3. Updates faces.jsonl and tracks.jsonl with new assignments
     *
     * This helps convert "noise" clusters (single-frame-only) into reviewable clusters.
     *
     * Args:
     *     frame_window: Number of frames to search before/after (default: 8)
     *     min_similarity: Minimum cosine similarity to merge faces (default: 0.70)
     *
     * Returns:
     *     tracks_analyzed: Number of single-frame tracks examined
     *     tracks_expanded: Number of tracks that were expanded
     *     faces_merged: Total faces added to tracks
     *     details: List of {track_id, original_frame, added_frames}
     */
    post: operations["recover_noise_tracks_episodes__ep_id__recover_noise_tracks_post"];
  };
  "/episodes/{ep_id}/video_meta": {
    /** Episode Video Meta */
    get: operations["episode_video_meta_episodes__ep_id__video_meta_get"];
  };
  "/episodes/{ep_id}/identities": {
    /** List Identities */
    get: operations["list_identities_episodes__ep_id__identities_get"];
  };
  "/episodes/{ep_id}/cluster_tracks": {
    /** List Cluster Tracks */
    get: operations["list_cluster_tracks_episodes__ep_id__cluster_tracks_get"];
  };
  "/episodes/{ep_id}/clusters/{cluster_id}/track_reps": {
    /**
     * Get Cluster Track Reps
     * @description Get representative frames with similarity scores for all tracks in a cluster.
     */
    get: operations["get_cluster_track_reps_episodes__ep_id__clusters__cluster_id__track_reps_get"];
  };
  "/episodes/{ep_id}/people/{person_id}/clusters_summary": {
    /**
     * Get Person Clusters Summary
     * @description Get clusters summary with track representatives for a person in an episode.
     */
    get: operations["get_person_clusters_summary_episodes__ep_id__people__person_id__clusters_summary_get"];
  };
  "/episodes/{ep_id}/faces_grid": {
    /** Faces Grid */
    get: operations["faces_grid_episodes__ep_id__faces_grid_get"];
  };
  "/episodes/{ep_id}/identities/{identity_id}": {
    /** Identity Detail */
    get: operations["identity_detail_episodes__ep_id__identities__identity_id__get"];
    /**
     * Delete Identity
     * @description Delete (archive) an identity/cluster.
     *
     * The cluster is moved to the archive where its centroid is stored.
     * This allows matching faces in future episodes to be auto-archived.
     */
    delete: operations["delete_identity_episodes__ep_id__identities__identity_id__delete"];
  };
  "/episodes/{ep_id}/tracks/{track_id}": {
    /** Track Detail */
    get: operations["track_detail_episodes__ep_id__tracks__track_id__get"];
    /** Delete Track */
    delete: operations["delete_track_episodes__ep_id__tracks__track_id__delete"];
  };
  "/episodes/{ep_id}/tracks/{track_id}/crops": {
    /** List Track Crops */
    get: operations["list_track_crops_episodes__ep_id__tracks__track_id__crops_get"];
  };
  "/episodes/{ep_id}/tracks/{track_id}/frames": {
    /** List Track Frames */
    get: operations["list_track_frames_episodes__ep_id__tracks__track_id__frames_get"];
    /** Delete Track Frames */
    delete: operations["delete_track_frames_episodes__ep_id__tracks__track_id__frames_delete"];
  };
  "/episodes/{ep_id}/tracks/{track_id}/integrity": {
    /** Track Integrity */
    get: operations["track_integrity_episodes__ep_id__tracks__track_id__integrity_get"];
  };
  "/episodes/{ep_id}/tracks/{track_id}/frames/move": {
    /** Move Track Frames */
    post: operations["move_track_frames_episodes__ep_id__tracks__track_id__frames_move_post"];
  };
  "/episodes/{ep_id}/identities/{identity_id}/rename": {
    /** Rename Identity */
    post: operations["rename_identity_episodes__ep_id__identities__identity_id__rename_post"];
  };
  "/episodes/{ep_id}/identities/{identity_id}/name": {
    /** Assign Identity Name */
    post: operations["assign_identity_name_episodes__ep_id__identities__identity_id__name_post"];
  };
  "/episodes/{ep_id}/tracks/{track_id}/name": {
    /** Assign Track Name */
    post: operations["assign_track_name_episodes__ep_id__tracks__track_id__name_post"];
  };
  "/episodes/{ep_id}/tracks/bulk_assign": {
    /**
     * Bulk Assign Tracks
     * @description Bulk assign multiple tracks to a cast member by name.
     *
     * This creates or updates identity assignments for each track, similar to
     * calling assign_track_name for each track individually but more efficient.
     */
    post: operations["bulk_assign_tracks_episodes__ep_id__tracks_bulk_assign_post"];
  };
  "/episodes/{ep_id}/identities/merge": {
    /** Merge Identities */
    post: operations["merge_identities_episodes__ep_id__identities_merge_post"];
  };
  "/episodes/{ep_id}/tracks/{track_id}/move": {
    /** Move Track */
    post: operations["move_track_episodes__ep_id__tracks__track_id__move_post"];
  };
  "/episodes/{ep_id}/faces/move_frames": {
    /** Move Faces */
    post: operations["move_faces_episodes__ep_id__faces_move_frames_post"];
  };
  "/episodes/{ep_id}/frames/{frame_idx}/overlay": {
    /**
     * Generate Frame Overlay
     * @description Generate a full-frame image with bounding boxes for all faces in that frame.
     *
     * This extracts the frame from the video, draws colored bounding boxes for each
     * track present in that frame, and saves the result as an overlay image.
     *
     * Returns:
     *     {
     *         "url": "path/to/overlay.jpg",
     *         "frame_idx": 804,
     *         "tracks": [{"track_id": 1, "bbox": [x1,y1,x2,y2]}, ...]
     *     }
     */
    post: operations["generate_frame_overlay_episodes__ep_id__frames__frame_idx__overlay_post"];
  };
  "/episodes/{ep_id}/frames": {
    /** Delete Frame */
    delete: operations["delete_frame_episodes__ep_id__frames_delete"];
  };
  "/episodes/{ep_id}/identities/{identity_id}/export_seeds": {
    /**
     * Export Facebank Seeds
     * @description Select and export high-quality seed frames to permanent facebank.
     * Only exports user-confirmed identities with person_id mappings.
     */
    post: operations["export_facebank_seeds_episodes__ep_id__identities__identity_id__export_seeds_post"];
  };
  "/episodes/{ep_id}/presence": {
    /**
     * Get Presence
     * @description Get current viewers for an episode.
     *
     * Returns list of users currently viewing this episode,
     * excluding viewers whose heartbeat has expired.
     */
    get: operations["get_presence_episodes__ep_id__presence_get"];
    /**
     * Update Presence
     * @description Update presence heartbeat for a user viewing an episode.
     *
     * Call this endpoint periodically (every 30s) to maintain presence.
     */
    post: operations["update_presence_episodes__ep_id__presence_post"];
    /**
     * Leave Presence
     * @description Remove presence for a user (when leaving the page).
     */
    delete: operations["leave_presence_episodes__ep_id__presence_delete"];
  };
  "/identities/{ep_id}/rename": {
    /** Rename Identity */
    post: operations["rename_identity_identities__ep_id__rename_post"];
  };
  "/identities/{ep_id}/merge": {
    /** Merge Identities */
    post: operations["merge_identities_identities__ep_id__merge_post"];
  };
  "/identities/{ep_id}/move_track": {
    /** Move Track */
    post: operations["move_track_identities__ep_id__move_track_post"];
  };
  "/identities/{ep_id}/drop_track": {
    /** Drop Track */
    post: operations["drop_track_identities__ep_id__drop_track_post"];
  };
  "/identities/{ep_id}/drop_frame": {
    /** Drop Frame */
    post: operations["drop_frame_identities__ep_id__drop_frame_post"];
  };
  "/shows/{show}/roster": {
    /** Get Roster */
    get: operations["get_roster_shows__show__roster_get"];
  };
  "/shows/{show}/roster/names": {
    /** Add Roster Name */
    post: operations["add_roster_name_shows__show__roster_names_post"];
  };
  "/shows/{show}/cast_names": {
    /** List Cast Names */
    get: operations["list_cast_names_shows__show__cast_names_get"];
    /** Add Cast Name */
    post: operations["add_cast_name_shows__show__cast_names_post"];
  };
  "/shows": {
    /** List Registered Shows */
    get: operations["list_registered_shows_shows_get"];
    /** Register Show */
    post: operations["register_show_shows_post"];
  };
  "/shows/{show_id}/cast": {
    /**
     * List Cast
     * @description Get all cast members for a show, optionally filtered by season.
     */
    get: operations["list_cast_shows__show_id__cast_get"];
    /**
     * Create Cast Member
     * @description Create a new cast member.
     */
    post: operations["create_cast_member_shows__show_id__cast_post"];
  };
  "/shows/{show_id}/cast/{cast_id}": {
    /**
     * Get Cast Member
     * @description Get a specific cast member.
     */
    get: operations["get_cast_member_shows__show_id__cast__cast_id__get"];
    /**
     * Delete Cast Member
     * @description Delete a cast member.
     */
    delete: operations["delete_cast_member_shows__show_id__cast__cast_id__delete"];
    /**
     * Update Cast Member
     * @description Update a cast member.
     */
    patch: operations["update_cast_member_shows__show_id__cast__cast_id__patch"];
  };
  "/shows/{show_id}/cast/import": {
    /**
     * Bulk Import Cast
     * @description Bulk import cast members.
     *
     * Members with matching names (case-insensitive) will be updated unless force_new=true.
     *
     * Example JSON:
     * {
     *   "members": [
     *     {
     *       "name": "Kyle Richards",
     *       "role": "main",
     *       "status": "active",
     *       "aliases": ["Kyle", "Kyle R"],
     *       "seasons": ["S01", "S02", "S03"]
     *     }
     *   ],
     *   "force_new": false
     * }
     */
    post: operations["bulk_import_cast_shows__show_id__cast_import_post"];
  };
  "/cast/{cast_id}/facebank": {
    /**
     * Get Facebank
     * @description Get facebank data for a cast member.
     */
    get: operations["get_facebank_cast__cast_id__facebank_get"];
  };
  "/cast/{cast_id}/seeds/upload": {
    /**
     * Upload Seeds
     * @description Upload seed images for a cast member.
     */
    post: operations["upload_seeds_cast__cast_id__seeds_upload_post"];
  };
  "/cast/{cast_id}/seeds": {
    /**
     * Delete Seeds
     * @description Delete seed images from a cast member's facebank.
     */
    delete: operations["delete_seeds_cast__cast_id__seeds_delete"];
  };
  "/cast/{cast_id}/seeds/{seed_id}/feature": {
    /**
     * Feature Seed
     * @description Mark a seed as the featured facebank image.
     */
    post: operations["feature_seed_cast__cast_id__seeds__seed_id__feature_post"];
  };
  "/cast/{cast_id}/seeds/{seed_id}/image": {
    /**
     * Get Seed Image
     * @description Serve a seed image file (fallback for local storage without S3).
     */
    get: operations["get_seed_image_cast__cast_id__seeds__seed_id__image_get"];
  };
  "/files/presign": {
    /**
     * Presign Image
     * @description Generate a presigned URL for an S3 object with proper content-type headers.
     */
    get: operations["presign_image_files_presign_get"];
  };
  "/files/health": {
    /**
     * Check Image Health
     * @description Check if an image exists and is accessible, with optional image diagnostics.
     */
    get: operations["check_image_health_files_health_get"];
  };
  "/health/detector": {
    /**
     * Check Detector Health
     * @description Check RetinaFace detector availability and status.
     */
    get: operations["check_detector_health_health_detector_get"];
  };
  "/jobs/jobs/facebank/backfill_display": {
    /**
     * Backfill Facebank Display
     * @description Regenerate missing or low-resolution facebank display derivatives.
     */
    post: operations["backfill_facebank_display_jobs_jobs_facebank_backfill_display_post"];
  };
  "/jobs/detect": {
    /** Enqueue Detect */
    post: operations["enqueue_detect_jobs_detect_post"];
  };
  "/jobs/track": {
    /** Enqueue Track */
    post: operations["enqueue_track_jobs_track_post"];
  };
  "/jobs/detect_track": {
    /** Run Detect Track */
    post: operations["run_detect_track_jobs_detect_track_post"];
  };
  "/jobs/faces_embed": {
    /** Run Faces Embed */
    post: operations["run_faces_embed_jobs_faces_embed_post"];
  };
  "/jobs/cluster": {
    /** Run Cluster */
    post: operations["run_cluster_jobs_cluster_post"];
  };
  "/jobs/detect_track_async": {
    /** Enqueue Detect Track Async */
    post: operations["enqueue_detect_track_async_jobs_detect_track_async_post"];
  };
  "/jobs/faces_embed_async": {
    /** Enqueue Faces Embed Async */
    post: operations["enqueue_faces_embed_async_jobs_faces_embed_async_post"];
  };
  "/jobs/cluster_async": {
    /** Enqueue Cluster Async */
    post: operations["enqueue_cluster_async_jobs_cluster_async_post"];
  };
  "/jobs/episode_cleanup_async": {
    /** Enqueue Episode Cleanup Async */
    post: operations["enqueue_episode_cleanup_async_jobs_episode_cleanup_async_post"];
  };
  "/jobs/screen_time/analyze": {
    /**
     * Analyze Screen Time
     * @description Analyze per-cast screen time from assigned faces and tracks.
     */
    post: operations["analyze_screen_time_jobs_screen_time_analyze_post"];
  };
  "/jobs": {
    /**
     * List Jobs
     * @description List all jobs, optionally filtered by episode and/or job type.
     */
    get: operations["list_jobs_jobs_get"];
  };
  "/jobs/{job_id}/progress": {
    /** Get Job Progress */
    get: operations["get_job_progress_jobs__job_id__progress_get"];
  };
  "/jobs/{job_id}": {
    /** Job Details */
    get: operations["job_details_jobs__job_id__get"];
  };
  "/jobs/{job_id}/cancel": {
    /** Cancel Job */
    post: operations["cancel_job_jobs__job_id__cancel_post"];
  };
  "/shows/{show_id}/people": {
    /**
     * List People
     * @description Get all people for a show.
     */
    get: operations["list_people_shows__show_id__people_get"];
    /**
     * Create Person
     * @description Create a new person.
     */
    post: operations["create_person_shows__show_id__people_post"];
  };
  "/shows/{show_id}/people/{person_id}": {
    /**
     * Get Person
     * @description Get a specific person.
     */
    get: operations["get_person_shows__show_id__people__person_id__get"];
    /**
     * Delete Person
     * @description Delete (archive) a person.
     *
     * The person is moved to the archive where their centroid is stored.
     * This allows matching faces in future episodes to be auto-archived.
     */
    delete: operations["delete_person_shows__show_id__people__person_id__delete"];
    /**
     * Update Person
     * @description Update a person.
     */
    patch: operations["update_person_shows__show_id__people__person_id__patch"];
  };
  "/shows/{show_id}/people/merge": {
    /**
     * Merge People
     * @description Merge source person into target person.
     */
    post: operations["merge_people_shows__show_id__people_merge_post"];
  };
  "/shows/{show_id}/people/{person_id}/add_alias": {
    /**
     * Add Alias
     * @description Add an alias to a person.
     */
    post: operations["add_alias_shows__show_id__people__person_id__add_alias_post"];
  };
  "/episodes/{ep_id}/clusters/group": {
    /**
     * Group Clusters
     * @description Group clusters either automatically or manually.
     *
     * Auto mode: Compute centroids, run within-episode grouping, then across-episode matching.
     * Manual mode: Assign specific clusters to a person (new or existing).
     */
    post: operations["group_clusters_episodes__ep_id__clusters_group_post"];
  };
  "/episodes/{ep_id}/clusters/batch_assign": {
    /**
     * Batch Assign Clusters
     * @description Batch assign multiple clusters to cast members in a single operation.
     *
     * This endpoint is optimized for bulk assignments - it loads data once and
     * processes all assignments together, significantly reducing latency compared
     * to multiple individual calls.
     *
     * Request body:
     *     assignments: List of {cluster_id, target_cast_id} pairs
     *
     * Returns:
     *     - status: "success" or "partial" (if some failed)
     *     - results: List of assignment results
     *     - succeeded: Count of successful assignments
     *     - failed: Count of failed assignments
     */
    post: operations["batch_assign_clusters_episodes__ep_id__clusters_batch_assign_post"];
  };
  "/episodes/{ep_id}/clusters/batch_assign_async": {
    /**
     * Batch Assign Clusters Async
     * @description Enqueue batch cluster assignment as background job (non-blocking).
     *
     * Execution Mode:
     *     - execution_mode="redis" (default): Enqueues job via Celery, returns 202 with job_id
     *     - execution_mode="local": Runs job synchronously in-process, returns result when done
     *
     * If Celery/Redis are unavailable, falls back to synchronous execution.
     */
    post: operations["batch_assign_clusters_async_episodes__ep_id__clusters_batch_assign_async_post"];
  };
  "/episodes/{ep_id}/clusters/group_async": {
    /**
     * Group Clusters Async
     * @description Enqueue auto-grouping as background job (non-blocking).
     *
     * Execution Mode:
     *     - execution_mode="redis" (default): Enqueues job via Celery, returns 202 with job_id
     *     - execution_mode="local": Runs job synchronously in-process, returns result when done
     *
     * Only supports strategy="auto". For manual/facebank, use the synchronous endpoint.
     * If Celery/Redis are unavailable, falls back to synchronous execution.
     */
    post: operations["group_clusters_async_episodes__ep_id__clusters_group_async_post"];
  };
  "/episodes/{ep_id}/clusters/group/progress": {
    /**
     * Group Clusters Progress
     * @description Return in-flight grouping progress for polling clients.
     */
    get: operations["group_clusters_progress_episodes__ep_id__clusters_group_progress_get"];
  };
  "/episodes/{ep_id}/cluster_centroids": {
    /**
     * Get Cluster Centroids
     * @description Get cluster centroids for an episode.
     */
    get: operations["get_cluster_centroids_episodes__ep_id__cluster_centroids_get"];
  };
  "/episodes/{ep_id}/cluster_centroids/compute": {
    /**
     * Compute Cluster Centroids
     * @description Compute cluster centroids for an episode.
     */
    post: operations["compute_cluster_centroids_episodes__ep_id__cluster_centroids_compute_post"];
  };
  "/episodes/{ep_id}/cluster_suggestions": {
    /**
     * Get Cluster Suggestions
     * @description Get suggested cast member matches for episode clusters.
     *
     * Returns suggestions based on similarity to existing people without actually assigning.
     */
    get: operations["get_cluster_suggestions_episodes__ep_id__cluster_suggestions_get"];
  };
  "/episodes/{ep_id}/cluster_suggestions_from_assigned": {
    /**
     * Get Cluster Suggestions From Assigned
     * @description Get suggested matches for unassigned clusters by comparing with assigned clusters.
     *
     * Compares unassigned cluster centroids against assigned cluster centroids in the same episode.
     * Returns suggestions based on which assigned person has the most similar cluster.
     */
    get: operations["get_cluster_suggestions_from_assigned_episodes__ep_id__cluster_suggestions_from_assigned_get"];
  };
  "/episodes/{ep_id}/clusters/{cluster_id}/suggest_cast": {
    /**
     * Suggest Cast For Cluster
     * @description Get cast member suggestions for a specific cluster (Enhancement #6).
     *
     * Compares the cluster's centroid against all cast member facebank seeds.
     * Returns top-k cast member suggestions with confidence levels.
     *
     * This endpoint is designed for on-demand "Suggest for Me" button clicks.
     */
    get: operations["suggest_cast_for_cluster_episodes__ep_id__clusters__cluster_id__suggest_cast_get"];
  };
  "/episodes/{ep_id}/cast_suggestions": {
    /**
     * Get Cast Suggestions
     * @description Get cast member suggestions for unassigned clusters based on facebank similarity.
     *
     * Compares each unassigned cluster's centroid against all cast member facebank seeds.
     * Returns top-k cast member suggestions per cluster with confidence levels.
     *
     * Query params:
     *     min_similarity: Minimum similarity threshold (default 0.50)
     *     top_k: Number of suggestions per cluster (default 3)
     */
    get: operations["get_cast_suggestions_episodes__ep_id__cast_suggestions_get"];
  };
  "/episodes/{ep_id}/unlinked_entities": {
    /**
     * List Unlinked Entities
     * @description Return clusters that are not linked to a cast member (auto-people + unassigned clusters).
     */
    get: operations["list_unlinked_entities_episodes__ep_id__unlinked_entities_get"];
  };
  "/episodes/{ep_id}/auto_link_cast": {
    /**
     * Auto Link Cast
     * @description Auto-assign unassigned clusters to cast members with high confidence (Enhancement #8).
     *
     * Only assigns when facebank similarity is >= min_confidence.
     * Called during Refresh Values to auto-link obvious matches.
     */
    post: operations["auto_link_cast_episodes__ep_id__auto_link_cast_post"];
  };
  "/episodes/{ep_id}/cleanup_preview": {
    /**
     * Cleanup Preview
     * @description Get a preview of what would change if cleanup were run (Enhancement #3).
     *
     * Analyzes current state and estimates impact without making changes.
     * Returns counts of affected clusters, manual assignments that could be impacted, etc.
     */
    get: operations["cleanup_preview_episodes__ep_id__cleanup_preview_get"];
  };
  "/episodes/{ep_id}/backup": {
    /**
     * Create Backup
     * @description Create backup before cleanup (Enhancement #7).
     *
     * Backs up identities.json, people.json, cluster_centroids.json.
     */
    post: operations["create_backup_episodes__ep_id__backup_post"];
  };
  "/episodes/{ep_id}/restore/{backup_id}": {
    /**
     * Restore Backup
     * @description Restore from a backup (Enhancement #7).
     */
    post: operations["restore_backup_episodes__ep_id__restore__backup_id__post"];
  };
  "/episodes/{ep_id}/backups": {
    /**
     * List Backups
     * @description List available backups for an episode (Enhancement #7).
     */
    get: operations["list_backups_episodes__ep_id__backups_get"];
  };
  "/episodes/{ep_id}/consistency_check": {
    /**
     * Cross Episode Consistency
     * @description Check for cross-episode inconsistencies (Enhancement #9).
     *
     * Finds clusters that might be the same person but are assigned differently.
     */
    get: operations["cross_episode_consistency_episodes__ep_id__consistency_check_get"];
  };
  "/episodes/{ep_id}/save_assignments": {
    /**
     * Save Assignments
     * @description Save all current cluster assignments to people.json and identities.json.
     *
     * This ensures all assignments made in the UI are persisted.
     */
    post: operations["save_assignments_episodes__ep_id__save_assignments_post"];
  };
  "/episodes/{ep_id}/undo_stack": {
    /**
     * Get Undo Stack
     * @description Get the undo stack for an episode.
     *
     * Returns list of operations that can be undone, with id, type, description, timestamp.
     */
    get: operations["get_undo_stack_episodes__ep_id__undo_stack_get"];
  };
  "/episodes/{ep_id}/undo": {
    /**
     * Undo Last Operation
     * @description Undo the last operation for an episode.
     *
     * Restores the state before the last undoable operation.
     */
    post: operations["undo_last_operation_episodes__ep_id__undo_post"];
  };
  "/episodes/{ep_id}/tiered_suggestions": {
    /**
     * Get Tiered Suggestions
     * @description Get cast suggestions tiered by confidence level.
     *
     * Returns suggestions in three tiers:
     * - high_confidence: Auto-assignable (≥85% similarity)
     * - medium_confidence: Review queue (68-85% similarity)
     * - low_confidence: Manual review required (<68% similarity)
     */
    get: operations["get_tiered_suggestions_episodes__ep_id__tiered_suggestions_get"];
  };
  "/episodes/{ep_id}/auto_assign_high_confidence": {
    /**
     * Auto Assign High Confidence
     * @description Auto-assign all high-confidence suggestions.
     *
     * Automatically assigns clusters to cast members when similarity exceeds threshold.
     *
     * Args:
     *     threshold: Minimum similarity for auto-assignment (default 0.85)
     */
    post: operations["auto_assign_high_confidence_episodes__ep_id__auto_assign_high_confidence_post"];
  };
  "/episodes/{ep_id}/potential_duplicates": {
    /**
     * Get Potential Duplicates
     * @description Find clusters that might be duplicates (same person split across clusters).
     *
     * Returns pairs of clusters that exceed the similarity threshold.
     */
    get: operations["get_potential_duplicates_episodes__ep_id__potential_duplicates_get"];
  };
  "/episodes/{ep_id}/merge_clusters": {
    /**
     * Merge Clusters
     * @description Merge multiple clusters into a single person.
     *
     * Args:
     *     cluster_ids: List of cluster IDs to merge
     *     target_person_id: Optional person ID to merge into (creates new if not provided)
     */
    post: operations["merge_clusters_episodes__ep_id__merge_clusters_post"];
  };
  "/episodes/{ep_id}/merge_all_duplicates": {
    /**
     * Merge All Duplicates
     * @description Automatically merge all high-similarity cluster pairs.
     *
     * Uses transitive closure to group connected clusters before merging.
     *
     * Args:
     *     similarity_threshold: Minimum similarity for auto-merge (default 0.90)
     */
    post: operations["merge_all_duplicates_episodes__ep_id__merge_all_duplicates_post"];
  };
  "/metadata/shows/{show_slug}": {
    /**
     * Read Show
     * @description Return show metadata from core.shows.
     *
     * Args:
     *     show_slug: Show identifier (e.g., 'RHOBH', 'RHOSLC')
     *
     * Returns:
     *     JSON object with show fields:
     *     - show_id: Primary key
     *     - show_slug: Show identifier
     *     - title: Display name
     *     - franchise: Franchise name (nullable)
     *     - network: Network name (nullable)
     *     - imdb_series_id: IMDb series ID (nullable)
     *     - tmdb_series_id: TMDb series ID (nullable)
     *     - is_active: Whether show is currently active
     *
     * Raises:
     *     HTTPException: 404 if show not found
     *     HTTPException: 500 if database connection or query fails
     */
    get: operations["read_show_metadata_shows__show_slug__get"];
  };
  "/metadata/shows/{show_slug}/seasons": {
    /**
     * Read Show Seasons
     * @description Return seasons for a show from core.seasons.
     *
     * Args:
     *     show_slug: Show identifier (e.g., 'RHOBH', 'RHOSLC')
     *
     * Returns:
     *     JSON object with:
     *     - show: Show metadata object
     *     - seasons: Array of season objects with fields:
     *       - season_id: Primary key
     *       - show_id: Foreign key to show
     *       - season_number: Season number
     *       - label: Display label (nullable)
     *       - is_current: Whether this is the current season
     *
     * Raises:
     *     HTTPException: 404 if show not found
     *     HTTPException: 500 if database connection or query fails
     */
    get: operations["read_show_seasons_metadata_shows__show_slug__seasons_get"];
  };
  "/metadata/shows/{show_slug}/episodes": {
    /**
     * Read Show Episodes
     * @description Return episodes for a show from core.episodes.
     *
     * Args:
     *     show_slug: Show identifier (e.g., 'RHOBH', 'RHOSLC')
     *
     * Returns:
     *     JSON object with:
     *     - show: Show metadata object
     *     - episodes: Array of episode objects with fields:
     *       - episode_id: Primary key
     *       - season_id: Foreign key to season
     *       - season_number: Season number (from join)
     *       - episode_number: Episode number within season
     *       - episode_code: Episode code (nullable, e.g. "S01E01")
     *       - title: Episode title (nullable)
     *       - air_date: Air date (nullable)
     *       - runtime_seconds: Runtime in seconds (nullable)
     *
     * Raises:
     *     HTTPException: 404 if show not found
     *     HTTPException: 500 if database connection or query fails
     */
    get: operations["read_show_episodes_metadata_shows__show_slug__episodes_get"];
  };
  "/metadata/shows/{show_slug}/cast": {
    /**
     * Read Show Cast
     * @description Return the canonical cast list for a given show slug from core.cast.
     *
     * Args:
     *     show_slug: Show identifier (e.g., 'RHOBH', 'RHOSLC')
     *
     * Returns:
     *     JSON array of cast member records with fields:
     *     - cast_id: Primary key (text or UUID)
     *     - show_slug: Show identifier
     *     - person_name: Cast member's name
     *     - imdb_person_id: IMDb person ID (nullable)
     *     - tmdb_person_id: TMDb person ID (nullable)
     *     - bravo_cast_slug: Stable UI slug (nullable)
     *     - sort_order: Display order hint (nullable)
     *
     * Raises:
     *     HTTPException: 404 if no cast found for the show
     *     HTTPException: 500 if database connection or query fails
     */
    get: operations["read_show_cast_metadata_shows__show_slug__cast_get"];
  };
  "/archive/shows/{show_id}": {
    /**
     * List Archived Items
     * @description List archived items for a show.
     *
     * Returns paginated list of archived people, clusters, and tracks.
     */
    get: operations["list_archived_items_archive_shows__show_id__get"];
  };
  "/archive/shows/{show_id}/stats": {
    /**
     * Get Archive Stats
     * @description Get archive statistics for a show.
     */
    get: operations["get_archive_stats_archive_shows__show_id__stats_get"];
  };
  "/archive/shows/{show_id}/match": {
    /**
     * Find Matching Archived
     * @description Find archived items matching a given face centroid.
     *
     * Used to check if a new face matches previously archived (rejected) faces.
     */
    post: operations["find_matching_archived_archive_shows__show_id__match_post"];
  };
  "/archive/shows/{show_id}/restore/{archive_id}": {
    /**
     * Restore Archived Item
     * @description Restore an archived person.
     *
     * Returns the original person data. The caller should use this
     * to recreate the person via the people API.
     */
    post: operations["restore_archived_item_archive_shows__show_id__restore__archive_id__post"];
  };
  "/archive/shows/{show_id}/{archive_id}": {
    /**
     * Permanently Delete Archived
     * @description Permanently delete an archived item.
     *
     * This cannot be undone - the item and its centroid will be gone forever.
     */
    delete: operations["permanently_delete_archived_archive_shows__show_id___archive_id__delete"];
  };
  "/archive/shows/{show_id}/centroids": {
    /**
     * Get Archived Centroids
     * @description Get all archived centroids for matching.
     *
     * Returns list of archived items with their centroid embeddings.
     * Used for auto-archiving matching faces in future episodes.
     */
    get: operations["get_archived_centroids_archive_shows__show_id__centroids_get"];
  };
  "/archive/shows/{show_id}/tracks": {
    /**
     * Archive Track
     * @description Archive a track before deletion.
     *
     * Stores the track metadata for potential future matching or restoration.
     */
    post: operations["archive_track_archive_shows__show_id__tracks_post"];
  };
  "/celery_jobs/local": {
    /**
     * List Local Jobs
     * @description List running local jobs (not Celery).
     *
     * These are subprocess jobs running on the local machine, detected either
     * from our registry or by scanning for episode_run.py processes.
     *
     * Args:
     *     ep_id: Optional filter by episode ID
     */
    get: operations["list_local_jobs_celery_jobs_local_get"];
  };
  "/celery_jobs/logs/{ep_id}/{operation}": {
    /**
     * Get Operation Logs
     * @description Get the most recent logs for an operation.
     *
     * This endpoint returns the last saved logs for a given episode and operation.
     * Logs are persisted when local mode jobs complete (success, error, or cancelled).
     *
     * Args:
     *     ep_id: Episode identifier
     *     operation: Operation name (detect_track, faces_embed, cluster)
     *
     * Returns:
     *     - status: "completed" | "error" | "cancelled" | "timeout" | "none"
     *     - logs: List of log lines (empty if status is "none")
     *     - elapsed_seconds: Runtime in seconds
     *     - updated_at: ISO timestamp of when logs were saved
     */
    get: operations["get_operation_logs_celery_jobs_logs__ep_id___operation__get"];
  };
  "/celery_jobs/{job_id}": {
    /**
     * Get Celery Job Status
     * @description Get status of a Celery background job.
     *
     * This endpoint returns status of jobs submitted via Redis/Celery mode.
     * Local mode jobs are synchronous and do not use this endpoint.
     *
     * Returns:
     *     - job_id: The job ID
     *     - state: Simplified state (queued, in_progress, success, failed, cancelled)
     *     - raw_state: Original Celery state
     *     - result: Job result if completed (success or failure)
     *     - progress: Progress metadata if job is running
     */
    get: operations["get_celery_job_status_celery_jobs__job_id__get"];
  };
  "/celery_jobs/{job_id}/cancel": {
    /**
     * Cancel Celery Job
     * @description Cancel a running Celery or local background job.
     *
     * Supports:
     * - Celery jobs: Sends revoke signal
     * - Local jobs (orphan-{pid}, local-{ep_id}-{operation}): Kills process by PID
     *
     * Note: This sends a termination signal. Long-running operations may take
     * a moment to actually stop.
     */
    post: operations["cancel_celery_job_celery_jobs__job_id__cancel_post"];
  };
  "/celery_jobs/kill_all_local": {
    /**
     * Kill All Local Jobs
     * @description Kill all local/orphan jobs, optionally filtered by episode.
     *
     * This is useful for cleaning up stale processes that weren't properly
     * terminated (e.g., after a crash or page refresh).
     *
     * Args:
     *     ep_id: Optional episode ID to filter jobs. If not provided, kills all local jobs.
     *
     * Returns:
     *     List of killed job IDs and their status.
     */
    post: operations["kill_all_local_jobs_celery_jobs_kill_all_local_post"];
  };
  "/celery_jobs": {
    /**
     * List Active Celery Jobs
     * @description List currently active Celery jobs.
     *
     * Note: This only shows jobs known to the current worker.
     * Completed jobs are available via their individual job_id.
     *
     * Each job now includes ep_id and operation for matching after page reload.
     */
    get: operations["list_active_celery_jobs_celery_jobs_get"];
  };
  "/celery_jobs/detect_track": {
    /**
     * Start Detect Track Celery
     * @description Start a detect/track job.
     *
     * Execution Mode:
     *     - execution_mode="redis" (default): Enqueues job via Celery, returns 202 with job_id
     *     - execution_mode="local": Runs job synchronously in-process, returns result when done
     *
     * Thermal Safety:
     *     - Resolves profile based on device (low_power for CPU/CoreML/MPS)
     *     - Auto-downgrades "performance" profile on non-CUDA devices
     *     - Always applies CPU thread limits (default: 2 for laptops)
     *
     * Check for active jobs before starting to prevent duplicate runs.
     */
    post: operations["start_detect_track_celery_celery_jobs_detect_track_post"];
  };
  "/celery_jobs/faces_embed": {
    /**
     * Start Faces Embed Celery
     * @description Start a faces embed (harvest) job.
     *
     * Execution Mode:
     *     - execution_mode="redis" (default): Enqueues job via Celery, returns 202 with job_id
     *     - execution_mode="local": Runs job synchronously in-process, returns result when done
     *
     * Thermal Safety:
     *     - Applies CPU thread limits for laptop-friendly operation
     */
    post: operations["start_faces_embed_celery_celery_jobs_faces_embed_post"];
  };
  "/celery_jobs/cluster": {
    /**
     * Start Cluster Celery
     * @description Start a clustering job.
     *
     * Execution Mode:
     *     - execution_mode="redis" (default): Enqueues job via Celery, returns 202 with job_id
     *     - execution_mode="local": Runs job synchronously in-process, returns result when done
     *
     * Thermal Safety:
     *     - Applies CPU thread limits for laptop-friendly operation
     */
    post: operations["start_cluster_celery_celery_jobs_cluster_post"];
  };
  "/celery_jobs/parallel": {
    /**
     * Start Parallel Jobs
     * @description Start the same operation on multiple episodes in parallel.
     *
     * Uses Celery group to execute jobs concurrently across episodes.
     * Returns a group_id that can be used to track overall progress.
     *
     * Args:
     *     episode_ids: List of episode IDs to process
     *     operation: Operation to run (auto_group, refresh_similarity, manual_assign)
     *     options: Options to pass to each task
     *
     * Returns:
     *     - group_id: ID to track the parallel job group
     *     - job_ids: Map of episode_id to individual job_id
     *     - status: "queued" or "error"
     */
    post: operations["start_parallel_jobs_celery_jobs_parallel_post"];
  };
  "/celery_jobs/parallel/{group_id}": {
    /**
     * Get Parallel Job Status
     * @description Get status of a parallel job group.
     *
     * Returns overall progress and per-episode results.
     *
     * Args:
     *     group_id: The group ID returned from /parallel endpoint
     *
     * Returns:
     *     - status: overall status (in_progress, success, partial_success, failed)
     *     - progress: fraction complete (0.0 to 1.0)
     *     - completed: number of completed jobs
     *     - failed: number of failed jobs
     *     - results: per-episode job status
     */
    get: operations["get_parallel_job_status_celery_jobs_parallel__group_id__get"];
  };
  "/celery_jobs/history": {
    /**
     * Get Job History Endpoint
     * @description Get job history for a user.
     *
     * Returns list of recent jobs with status and timing information.
     *
     * Args:
     *     user_id: User identifier (defaults to "anonymous")
     *     limit: Maximum number of records (default 20)
     *     offset: Number of records to skip (for pagination)
     *
     * Returns:
     *     List of job records, newest first
     */
    get: operations["get_job_history_endpoint_celery_jobs_history_get"];
  };
  "/celery_jobs/active": {
    /**
     * Get Active Jobs Endpoint
     * @description Get all active (queued/in_progress) jobs for a user.
     *
     * This is useful for the "My Jobs" panel to show what's currently running.
     *
     * Args:
     *     user_id: User identifier (defaults to "anonymous")
     *
     * Returns:
     *     List of active job records with current status
     */
    get: operations["get_active_jobs_endpoint_celery_jobs_active_get"];
  };
  "/health": {
    /** Health */
    get: operations["health_health_get"];
  };
  "/healthz": {
    /**
     * Healthz
     * @description Lightweight health check - must not block on heavy imports or GIL-holding operations.
     */
    get: operations["healthz_healthz_get"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /** AnalyzeScreenTimeRequest */
    AnalyzeScreenTimeRequest: {
      /**
       * Ep Id
       * @description Episode identifier
       */
      ep_id: string;
      /**
       * Quality Min
       * @description Minimum face quality threshold
       */
      quality_min?: number | null;
      /**
       * Gap Tolerance S
       * @description Gap tolerance in seconds
       */
      gap_tolerance_s?: number | null;
      /**
       * Use Video Decode
       * @description Use video decode for precise timestamps
       */
      use_video_decode?: boolean | null;
      /**
       * Screen Time Mode
       * @description How to derive intervals for screen time aggregation
       */
      screen_time_mode?: ("faces" | "tracks") | null;
      /**
       * Edge Padding S
       * @description Edge padding (seconds) applied to each interval
       */
      edge_padding_s?: number | null;
      /**
       * Track Coverage Min
       * @description Minimum detection coverage when using track mode
       */
      track_coverage_min?: number | null;
      /**
       * Preset
       * @description Named preset defined in config/pipeline/screen_time_v2.yaml
       */
      preset?: string | null;
    };
    /**
     * ArchiveTrackRequest
     * @description Request to archive a track.
     */
    ArchiveTrackRequest: {
      /**
       * Episode Id
       * @description Episode ID
       */
      episode_id: string;
      /**
       * Track Id
       * @description Track ID
       */
      track_id: number;
      /**
       * Reason
       * @description Reason for archiving
       * @default user_archived
       */
      reason?: string;
      /**
       * Cluster Id
       * @description Parent cluster ID
       */
      cluster_id?: string | null;
      /**
       * Centroid
       * @description Track centroid embedding
       */
      centroid?: number[] | null;
      /**
       * Rep Crop Url
       * @description Representative crop URL
       */
      rep_crop_url?: string | null;
      /**
       * Frame Count
       * @description Number of frames in this track
       * @default 0
       */
      frame_count?: number;
    };
    /** AssetUploadResponse */
    AssetUploadResponse: {
      /** Ep Id */
      ep_id: string;
      /** Method */
      method: string;
      /** Bucket */
      bucket: string;
      /** Key */
      key: string;
      /** Object Key */
      object_key?: string | null;
      /** Upload Url */
      upload_url: string | null;
      /** Expires In */
      expires_in: number | null;
      /** Headers */
      headers: {
        [key: string]: string;
      };
      /** Path */
      path?: string | null;
      /** Local Video Path */
      local_video_path: string;
      /** Backend */
      backend: string;
    };
    /**
     * BatchAssignRequest
     * @description Batch assignment request for multiple clusters to multiple cast members.
     */
    BatchAssignRequest: {
      /**
       * Assignments
       * @description List of cluster-to-cast assignments
       */
      assignments: components["schemas"]["BatchAssignmentItem"][];
      /**
       * Execution Mode
       * @description Execution mode: 'redis' enqueues job via Celery, 'local' runs synchronously in-process
       * @default redis
       */
      execution_mode?: ("redis" | "local") | null;
    };
    /**
     * BatchAssignmentItem
     * @description Single assignment in a batch.
     */
    BatchAssignmentItem: {
      /**
       * Cluster Id
       * @description Cluster ID to assign
       */
      cluster_id: string;
      /**
       * Target Cast Id
       * @description Cast ID to assign the cluster to
       */
      target_cast_id: string;
    };
    /** Body_upload_seeds_cast__cast_id__seeds_upload_post */
    Body_upload_seeds_cast__cast_id__seeds_upload_post: {
      /** Files */
      files: string[];
    };
    /** BulkImportRequest */
    BulkImportRequest: {
      /**
       * Members
       * @description List of cast member data
       */
      members: Record<string, never>[];
      /**
       * Force New
       * @description Always create new members (skip merge by name)
       * @default false
       */
      force_new?: boolean;
    };
    /** BulkTrackAssignRequest */
    BulkTrackAssignRequest: {
      /**
       * Track Ids
       * @description List of track IDs to assign
       */
      track_ids: number[];
      /**
       * Name
       * @description Name to assign
       */
      name: string;
      /**
       * Show
       * @description Optional show slug override
       */
      show?: string | null;
      /**
       * Cast Id
       * @description Optional cast_id to link assignment
       */
      cast_id?: string | null;
    };
    /** CastMemberCreateRequest */
    CastMemberCreateRequest: {
      /**
       * Name
       * @description Cast member name
       */
      name: string;
      /**
       * Full Name
       * @description Legal/full name
       */
      full_name?: string | null;
      /**
       * Role
       * @description Role: main, friend, guest, other
       * @default other
       */
      role?: string;
      /**
       * Status
       * @description Status: active, past, inactive
       * @default active
       */
      status?: string;
      /**
       * Aliases
       * @description Aliases/nicknames
       */
      aliases?: string[] | null;
      /**
       * Seasons
       * @description Season IDs (e.g., S05)
       */
      seasons?: string[] | null;
      /**
       * Social
       * @description Social media handles
       */
      social?: Record<string, never> | null;
      /**
       * Imdb Id
       * @description IMDb person identifier (e.g., nm0000001)
       */
      imdb_id?: string | null;
    };
    /** CastMemberResponse */
    CastMemberResponse: {
      /** Cast Id */
      cast_id: string;
      /** Show Id */
      show_id: string;
      /** Name */
      name: string;
      /** Full Name */
      full_name?: string | null;
      /** Role */
      role: string;
      /** Status */
      status: string;
      /** Aliases */
      aliases: string[];
      /** Seasons */
      seasons: string[];
      /** Social */
      social: Record<string, never>;
      /** Imdb Id */
      imdb_id?: string | null;
      /** Created At */
      created_at: string;
      /** Updated At */
      updated_at: string;
    };
    /** CastMemberUpdateRequest */
    CastMemberUpdateRequest: {
      /** Name */
      name?: string | null;
      /** Full Name */
      full_name?: string | null;
      /** Role */
      role?: string | null;
      /** Status */
      status?: string | null;
      /** Aliases */
      aliases?: string[] | null;
      /** Seasons */
      seasons?: string[] | null;
      /** Social */
      social?: Record<string, never> | null;
      /** Imdb Id */
      imdb_id?: string | null;
    };
    /** CastNameRequest */
    CastNameRequest: {
      /** Name */
      name: string;
    };
    /** CleanupJobRequest */
    CleanupJobRequest: {
      /**
       * Ep Id
       * @description Episode identifier
       */
      ep_id: string;
      /**
       * Profile
       * @description Performance profile (fast_cpu/low_power/balanced/high_accuracy). Applies to all cleanup stages.
       */
      profile?: ("fast_cpu" | "low_power" | "balanced" | "high_accuracy") | null;
      /**
       * Stride
       * @default 4
       */
      stride?: number;
      /** Fps */
      fps?: number | null;
      /**
       * Device
       * @description Detect/track device (auto→CUDA→CoreML→CPU)
       * @default auto
       * @enum {string}
       */
      device?: "auto" | "cpu" | "mps" | "coreml" | "metal" | "apple" | "cuda";
      /**
       * Embed Device
       * @description Faces embed device (supports coreml/metal/apple alias)
       * @default auto
       * @enum {string}
       */
      embed_device?: "auto" | "cpu" | "mps" | "coreml" | "metal" | "apple" | "cuda";
      /**
       * Detector
       * @description Detector backend (retinaface)
       * @default retinaface
       */
      detector?: string;
      /**
       * Tracker
       * @description Tracker backend
       * @default bytetrack
       */
      tracker?: string;
      /**
       * Max Gap
       * @default 30
       */
      max_gap?: number;
      /** Det Thresh */
      det_thresh?: number | null;
      /**
       * Save Frames
       * @default false
       */
      save_frames?: boolean;
      /**
       * Save Crops
       * @default false
       */
      save_crops?: boolean;
      /**
       * Jpeg Quality
       * @default 72
       */
      jpeg_quality?: number;
      /**
       * Scene Detector
       * @default pyscenedetect
       * @enum {string}
       */
      scene_detector?: "pyscenedetect" | "internal" | "off";
      /**
       * Scene Threshold
       * @default 27
       */
      scene_threshold?: number;
      /**
       * Scene Min Len
       * @default 12
       */
      scene_min_len?: number;
      /**
       * Scene Warmup Dets
       * @default 3
       */
      scene_warmup_dets?: number;
      /**
       * Cluster Thresh
       * @default 0.7
       */
      cluster_thresh?: number;
      /**
       * Min Cluster Size
       * @default 2
       */
      min_cluster_size?: number;
      /**
       * Min Identity Sim
       * @default 0.5
       */
      min_identity_sim?: number;
      /**
       * Thumb Size
       * @default 256
       */
      thumb_size?: number;
      /** Actions */
      actions?: ("split_tracks" | "reembed" | "recluster" | "group_clusters")[];
      /**
       * Write Back
       * @description Update people.json with grouping assignments
       * @default true
       */
      write_back?: boolean;
    };
    /**
     * ClusterCeleryRequest
     * @description Request model for Celery-based cluster job.
     */
    ClusterCeleryRequest: {
      /**
       * Ep Id
       * @description Episode identifier
       */
      ep_id: string;
      /**
       * Device
       * @description Execution device
       * @default auto
       * @enum {string}
       */
      device?: "auto" | "cpu" | "mps" | "coreml" | "metal" | "apple" | "cuda";
      /**
       * Cluster Thresh
       * @description Clustering threshold
       * @default 0.7
       */
      cluster_thresh?: number;
      /**
       * Min Cluster Size
       * @description Minimum cluster size
       * @default 2
       */
      min_cluster_size?: number;
      /**
       * Min Identity Sim
       * @description Min identity similarity
       * @default 0.5
       */
      min_identity_sim?: number | null;
      /**
       * Cpu Threads
       * @description CPU thread cap
       */
      cpu_threads?: number | null;
      /**
       * Profile
       * @description Performance profile
       */
      profile?: string | null;
      /**
       * Allow Cpu Fallback
       * @description Allow falling back to CPU if requested accelerator is unavailable.
       * @default false
       */
      allow_cpu_fallback?: boolean;
      /**
       * Execution Mode
       * @description Execution mode: 'redis' enqueues job via Celery, 'local' runs synchronously in-process
       * @default redis
       */
      execution_mode?: ("redis" | "local") | null;
    };
    /** ClusterRequest */
    ClusterRequest: {
      /**
       * Ep Id
       * @description Episode identifier
       */
      ep_id: string;
      /**
       * Profile
       * @description Performance profile (fast_cpu/low_power/balanced/high_accuracy). Controls clustering thresholds.
       */
      profile?: ("fast_cpu" | "low_power" | "balanced" | "high_accuracy") | null;
      /**
       * Device
       * @description Execution device (defaults to server auto-detect with CUDA/CoreML fallbacks)
       */
      device?: ("auto" | "cpu" | "mps" | "coreml" | "metal" | "apple" | "cuda") | null;
      /**
       * Cluster Thresh
       * @description Minimum cosine similarity for clustering (converted to 1-sim distance)
       * @default 0.7
       */
      cluster_thresh?: number;
      /**
       * Min Cluster Size
       * @description Minimum tracks per identity
       * @default 2
       */
      min_cluster_size?: number;
      /**
       * Min Identity Sim
       * @description Minimum cosine similarity for a track to remain in an identity cluster
       * @default 0.5
       */
      min_identity_sim?: number;
    };
    /** DeleteAllIn */
    DeleteAllIn: {
      /** Confirm */
      confirm: string;
      /**
       * Include S3
       * @default false
       */
      include_s3?: boolean;
    };
    /** DeleteEpisodeIn */
    DeleteEpisodeIn: {
      /**
       * Include S3
       * @default true
       */
      include_s3?: boolean;
      /**
       * Delete Raw
       * @default false
       */
      delete_raw?: boolean;
      /**
       * Delete Local
       * @default true
       */
      delete_local?: boolean;
    };
    /** DeleteEpisodeLegacyIn */
    DeleteEpisodeLegacyIn: {
      /**
       * Delete Artifacts
       * @default true
       */
      delete_artifacts?: boolean;
      /**
       * Delete Raw
       * @default false
       */
      delete_raw?: boolean;
      /**
       * Delete Local
       * @default true
       */
      delete_local?: boolean;
    };
    /** DeleteSeedsRequest */
    DeleteSeedsRequest: {
      /**
       * Seed Ids
       * @description List of seed IDs to delete
       */
      seed_ids: string[];
    };
    /** DetectRequest */
    DetectRequest: {
      /**
       * Ep Id
       * @description Episode identifier
       */
      ep_id: string;
      /**
       * Video
       * @description Source video path or URL
       */
      video: string;
      /**
       * Profile
       * @description Performance profile (fast_cpu/low_power/balanced/high_accuracy). Overrides stride/FPS/min_size defaults.
       */
      profile?: ("fast_cpu" | "low_power" | "balanced" | "high_accuracy") | null;
      /**
       * Stride
       * @description Frame stride for detection sampling (default 4 aligns with detect+track 42-minute runs)
       * @default 4
       */
      stride?: number;
      /**
       * Fps
       * @description Optional target FPS for sampling
       */
      fps?: number | null;
      /**
       * Device
       * @description Execution device (auto→CUDA→CoreML→CPU; accepts coreml/metal/apple aliases)
       * @default auto
       * @enum {string}
       */
      device?: "auto" | "cpu" | "mps" | "coreml" | "metal" | "apple" | "cuda";
    };
    /**
     * DetectTrackCeleryRequest
     * @description Request model for Celery-based detect/track job.
     */
    DetectTrackCeleryRequest: {
      /**
       * Ep Id
       * @description Episode identifier
       */
      ep_id: string;
      /**
       * Stride
       * @description Frame stride for detection sampling
       * @default 6
       */
      stride?: number;
      /**
       * Fps
       * @description Optional target FPS for sampling
       */
      fps?: number | null;
      /**
       * Device
       * @description Execution device
       * @default auto
       * @enum {string}
       */
      device?: "auto" | "cpu" | "mps" | "coreml" | "metal" | "apple" | "cuda";
      /**
       * Detector
       * @description Face detector backend
       * @default retinaface
       */
      detector?: string;
      /**
       * Tracker
       * @description Tracker backend
       * @default bytetrack
       */
      tracker?: string;
      /**
       * Save Frames
       * @description Save sampled frames
       * @default false
       */
      save_frames?: boolean;
      /**
       * Save Crops
       * @description Save face crops
       * @default false
       */
      save_crops?: boolean;
      /**
       * Jpeg Quality
       * @description JPEG quality
       * @default 72
       */
      jpeg_quality?: number;
      /**
       * Det Thresh
       * @description Detection threshold
       * @default 0.5
       */
      det_thresh?: number | null;
      /**
       * Max Gap
       * @description Max frame gap before new track
       * @default 30
       */
      max_gap?: number | null;
      /**
       * Scene Detector
       * @description Scene detector backend
       */
      scene_detector?: string | null;
      /**
       * Scene Threshold
       * @description Scene cut threshold
       */
      scene_threshold?: number | null;
      /**
       * Scene Min Len
       * @description Minimum frames between scene cuts
       */
      scene_min_len?: number | null;
      /**
       * Scene Warmup Dets
       * @description Forced detections after each cut
       */
      scene_warmup_dets?: number | null;
      /**
       * Track High Thresh
       * @description ByteTrack track_high_thresh override
       */
      track_high_thresh?: number | null;
      /**
       * New Track Thresh
       * @description ByteTrack new_track_thresh override
       */
      new_track_thresh?: number | null;
      /**
       * Track Buffer
       * @description ByteTrack base track_buffer before stride scaling
       */
      track_buffer?: number | null;
      /**
       * Min Box Area
       * @description ByteTrack min_box_area override
       */
      min_box_area?: number | null;
      /**
       * Cpu Threads
       * @description CPU thread cap for detect/track run
       */
      cpu_threads?: number | null;
      /**
       * Profile
       * @description Performance profile
       */
      profile?: string | null;
      /**
       * Allow Cpu Fallback
       * @description Allow falling back to CPU if requested accelerator (coreml/cuda) is unavailable. If False (default), fails fast with an error when accelerator is unavailable.
       * @default false
       */
      allow_cpu_fallback?: boolean;
      /**
       * Execution Mode
       * @description Execution mode: 'redis' enqueues job via Celery, 'local' runs synchronously in-process
       * @default redis
       */
      execution_mode?: ("redis" | "local") | null;
    };
    /** DetectTrackRequest */
    DetectTrackRequest: {
      /**
       * Ep Id
       * @description Episode identifier
       */
      ep_id: string;
      /**
       * Profile
       * @description Performance profile (fast_cpu/low_power/balanced/high_accuracy). Overrides stride/FPS/min_size defaults.
       */
      profile?: ("fast_cpu" | "low_power" | "balanced" | "high_accuracy") | null;
      /**
       * Stride
       * @description Frame stride for detection sampling (default: 6)
       * @default 6
       */
      stride?: number;
      /**
       * Fps
       * @description Optional target FPS for sampling
       */
      fps?: number | null;
      /**
       * Device
       * @description Execution device (auto→CUDA→CoreML→CPU; accepts coreml/metal/apple aliases)
       * @default auto
       * @enum {string}
       */
      device?: "auto" | "cpu" | "mps" | "coreml" | "metal" | "apple" | "cuda";
      /**
       * Save Frames
       * @description Sample full-frame JPGs to S3/local frames root
       * @default false
       */
      save_frames?: boolean;
      /**
       * Save Crops
       * @description Save per-track crops (requires tracks)
       * @default false
       */
      save_crops?: boolean;
      /**
       * Jpeg Quality
       * @description JPEG quality for frame/crop exports
       * @default 72
       */
      jpeg_quality?: number;
      /**
       * Detector
       * @description Face detector backend (retinaface)
       * @default retinaface
       */
      detector?: string;
      /**
       * Tracker
       * @description Tracker backend (bytetrack or strongsort)
       * @default bytetrack
       */
      tracker?: string;
      /**
       * Max Gap
       * @description Frame gap before forcing a new track
       * @default 30
       */
      max_gap?: number | null;
      /**
       * Det Thresh
       * @description RetinaFace detection threshold (0-1)
       * @default 0.5
       */
      det_thresh?: number | null;
      /**
       * Scene Detector
       * @description Scene-cut detector backend (PySceneDetect default, internal fallback, or off)
       * @default pyscenedetect
       * @enum {string}
       */
      scene_detector?: "pyscenedetect" | "internal" | "off";
      /**
       * Scene Threshold
       * @description Scene-cut threshold passed to the selected detector
       * @default 27
       */
      scene_threshold?: number;
      /**
       * Scene Min Len
       * @description Minimum frames between detected cuts
       * @default 12
       */
      scene_min_len?: number;
      /**
       * Scene Warmup Dets
       * @description Frames forced to run detection immediately after a cut
       * @default 3
       */
      scene_warmup_dets?: number;
      /**
       * Track High Thresh
       * @description Optional ByteTrack track_high_thresh override (default 0.5 or env)
       */
      track_high_thresh?: number | null;
      /**
       * New Track Thresh
       * @description Optional ByteTrack new_track_thresh override (default 0.5 or env)
       */
      new_track_thresh?: number | null;
      /**
       * Track Buffer
       * @description Optional ByteTrack base track_buffer before stride scaling
       */
      track_buffer?: number | null;
      /**
       * Min Box Area
       * @description Optional ByteTrack min_box_area override
       */
      min_box_area?: number | null;
      /**
       * Cpu Threads
       * @description CPU thread limit for ML libraries (OMP, MKL, etc.)
       */
      cpu_threads?: number | null;
    };
    /** DropFrameRequest */
    DropFrameRequest: {
      /** Track Id */
      track_id: number;
      /** Frame Idx */
      frame_idx: number;
      /**
       * Delete Assets
       * @default false
       */
      delete_assets?: boolean;
    };
    /** DropTrackRequest */
    DropTrackRequest: {
      /** Track Id */
      track_id: number;
    };
    /** EpisodeCreateRequest */
    EpisodeCreateRequest: {
      /**
       * Show Slug Or Id
       * @description Show slug or identifier
       */
      show_slug_or_id: string;
      /**
       * Season Number
       * @description Season number
       */
      season_number: number;
      /**
       * Episode Number
       * @description Episode number within the season
       */
      episode_number: number;
      /** Title */
      title?: string | null;
      /** Air Date */
      air_date?: string | null;
    };
    /** EpisodeCreateResponse */
    EpisodeCreateResponse: {
      /** Ep Id */
      ep_id: string;
    };
    /** EpisodeDetailResponse */
    EpisodeDetailResponse: {
      /** Ep Id */
      ep_id: string;
      /** Show Slug */
      show_slug: string;
      /** Season Number */
      season_number: number;
      /** Episode Number */
      episode_number: number;
      /** Title */
      title: string | null;
      /** Air Date */
      air_date: string | null;
      s3: components["schemas"]["EpisodeS3Status"];
      local: components["schemas"]["EpisodeLocalStatus"];
    };
    /** EpisodeListResponse */
    EpisodeListResponse: {
      /** Episodes */
      episodes: components["schemas"]["EpisodeSummary"][];
    };
    /** EpisodeLocalStatus */
    EpisodeLocalStatus: {
      /** Path */
      path: string;
      /** Exists */
      exists: boolean;
    };
    /** EpisodeMirrorResponse */
    EpisodeMirrorResponse: {
      /** Ep Id */
      ep_id: string;
      /** Local Video Path */
      local_video_path: string;
      /** Bytes */
      bytes?: number | null;
      /** Etag */
      etag?: string | null;
      /** Used Key Version */
      used_key_version?: string | null;
    };
    /** EpisodeS3Status */
    EpisodeS3Status: {
      /** Bucket */
      bucket: string;
      /** V2 Key */
      v2_key?: string | null;
      /**
       * V2 Exists
       * @default false
       */
      v2_exists?: boolean;
      /** V1 Key */
      v1_key: string;
      /** V1 Exists */
      v1_exists: boolean;
    };
    /** EpisodeStatusResponse */
    EpisodeStatusResponse: {
      /** Ep Id */
      ep_id: string;
      detect_track: components["schemas"]["PhaseStatus"];
      faces_embed: components["schemas"]["PhaseStatus"];
      cluster: components["schemas"]["PhaseStatus"];
      /** Scenes Ready */
      scenes_ready: boolean;
      /** Tracks Ready */
      tracks_ready: boolean;
      /** Faces Harvested */
      faces_harvested: boolean;
      /** Coreml Available */
      coreml_available?: boolean | null;
      /**
       * Faces Stale
       * @default false
       */
      faces_stale?: boolean;
      /**
       * Cluster Stale
       * @default false
       */
      cluster_stale?: boolean;
      /**
       * Faces Manifest Fallback
       * @default false
       */
      faces_manifest_fallback?: boolean;
      /**
       * Tracks Only Fallback
       * @default false
       */
      tracks_only_fallback?: boolean;
    };
    /** EpisodeSummary */
    EpisodeSummary: {
      /** Ep Id */
      ep_id: string;
      /** Show Slug */
      show_slug: string;
      /** Season Number */
      season_number: number;
      /** Episode Number */
      episode_number: number;
      /** Title */
      title: string | null;
      /** Air Date */
      air_date: string | null;
    };
    /** EpisodeUpsert */
    EpisodeUpsert: {
      /**
       * Ep Id
       * @description Deterministic ep_id (slug-sXXeYY)
       */
      ep_id: string;
      /** Show Slug */
      show_slug: string;
      /** Season */
      season: number;
      /** Episode */
      episode: number;
      /** Title */
      title?: string | null;
      /** Air Date */
      air_date?: string | null;
    };
    /** EpisodeVideoMeta */
    EpisodeVideoMeta: {
      /** Ep Id */
      ep_id: string;
      /** Local Exists */
      local_exists: boolean;
      /** Local Video Path */
      local_video_path: string;
      /** Width */
      width?: number | null;
      /** Height */
      height?: number | null;
      /** Frames */
      frames?: number | null;
      /** Duration Sec */
      duration_sec?: number | null;
      /** Fps Detected */
      fps_detected?: number | null;
    };
    /** FaceMoveRequest */
    FaceMoveRequest: {
      /** From Track Id */
      from_track_id: number;
      /**
       * Face Ids
       * @description Face identifiers to move
       */
      face_ids: string[];
      /**
       * Target Identity Id
       * @description Existing identity to receive frames
       */
      target_identity_id?: string | null;
      /**
       * New Identity Name
       * @description Create a new identity with this name
       */
      new_identity_name?: string | null;
      /**
       * Show Id
       * @description Optional show slug for roster updates
       */
      show_id?: string | null;
    };
    /** FacebankBackfillRequest */
    FacebankBackfillRequest: {
      /**
       * Show Id
       * @description Show identifier (e.g., RHOBH)
       */
      show_id: string;
      /**
       * Cast Id
       * @description Optional cast id to limit reprocessing
       */
      cast_id?: string | null;
      /**
       * Dry Run
       * @description When True, report actions without writing files or uploading to S3
       * @default false
       */
      dry_run?: boolean;
    };
    /** FacebankResponse */
    FacebankResponse: {
      /** Show Id */
      show_id: string;
      /** Cast Id */
      cast_id: string;
      /** Seeds */
      seeds: Record<string, never>[];
      /** Exemplars */
      exemplars: Record<string, never>[];
      /** Stats */
      stats: Record<string, never>;
      /** Featured Seed Id */
      featured_seed_id?: string | null;
      /** Similarity */
      similarity?: Record<string, never> | null;
    };
    /**
     * FacesEmbedCeleryRequest
     * @description Request model for Celery-based faces embed (harvest) job.
     */
    FacesEmbedCeleryRequest: {
      /**
       * Ep Id
       * @description Episode identifier
       */
      ep_id: string;
      /**
       * Device
       * @description Execution device
       * @default auto
       * @enum {string}
       */
      device?: "auto" | "cpu" | "mps" | "coreml" | "metal" | "apple" | "cuda";
      /**
       * Save Frames
       * @description Save sampled frames
       * @default false
       */
      save_frames?: boolean;
      /**
       * Save Crops
       * @description Save face crops (enable explicitly to avoid storage bloat)
       * @default false
       */
      save_crops?: boolean;
      /**
       * Jpeg Quality
       * @description JPEG quality
       * @default 72
       */
      jpeg_quality?: number;
      /**
       * Min Frames Between Crops
       * @description Min frames between crops
       * @default 32
       */
      min_frames_between_crops?: number;
      /**
       * Thumb Size
       * @description Thumbnail size
       * @default 256
       */
      thumb_size?: number;
      /**
       * Cpu Threads
       * @description CPU thread cap
       */
      cpu_threads?: number | null;
      /**
       * Profile
       * @description Performance profile
       */
      profile?: string | null;
      /**
       * Allow Cpu Fallback
       * @description Allow falling back to CPU if requested accelerator is unavailable.
       * @default false
       */
      allow_cpu_fallback?: boolean;
      /**
       * Execution Mode
       * @description Execution mode: 'redis' enqueues job via Celery, 'local' runs synchronously in-process
       * @default redis
       */
      execution_mode?: ("redis" | "local") | null;
    };
    /** FacesEmbedRequest */
    FacesEmbedRequest: {
      /**
       * Ep Id
       * @description Episode identifier
       */
      ep_id: string;
      /**
       * Profile
       * @description Performance profile (fast_cpu/low_power/balanced/high_accuracy). Controls quality gating and sampling.
       */
      profile?: ("fast_cpu" | "low_power" | "balanced" | "high_accuracy") | null;
      /**
       * Device
       * @description Execution device (auto→CUDA→CoreML→CPU; accepts coreml/metal/apple aliases)
       */
      device?: ("auto" | "cpu" | "mps" | "coreml" | "metal" | "apple" | "cuda") | null;
      /**
       * Save Frames
       * @description Export sampled frames alongside crops
       * @default false
       */
      save_frames?: boolean;
      /**
       * Save Crops
       * @description Export crops to data/frames + S3
       * @default false
       */
      save_crops?: boolean;
      /**
       * Jpeg Quality
       * @description JPEG quality for face crops
       * @default 72
       */
      jpeg_quality?: number;
      /**
       * Min Frames Between Crops
       * @description Minimum frame gap between successive crops on the same track
       * @default 32
       */
      min_frames_between_crops?: number;
      /**
       * Thumb Size
       * @description Square thumbnail size
       * @default 256
       */
      thumb_size?: number;
      /**
       * Cpu Threads
       * @description CPU thread limit for ML libraries (OMP, MKL, etc.)
       */
      cpu_threads?: number | null;
    };
    /** FeatureSeedResponse */
    FeatureSeedResponse: {
      /** Cast Id */
      cast_id: string;
      /** Seed Id */
      seed_id: string;
      /** Image Uri */
      image_uri: string;
    };
    /** FrameDeleteRequest */
    FrameDeleteRequest: {
      /** Track Id */
      track_id: number;
      /** Frame Idx */
      frame_idx: number;
      /**
       * Delete Assets
       * @default false
       */
      delete_assets?: boolean;
    };
    /** GroupClustersRequest */
    GroupClustersRequest: {
      /**
       * Strategy
       * @description Grouping strategy
       * @default auto
       * @enum {string}
       */
      strategy?: "auto" | "manual" | "facebank";
      /**
       * Cluster Ids
       * @description Cluster IDs for manual grouping
       */
      cluster_ids?: string[] | null;
      /**
       * Target Person Id
       * @description Target person ID for manual grouping
       */
      target_person_id?: string | null;
      /**
       * Cast Id
       * @description Cast ID to link to the person (for new or existing)
       */
      cast_id?: string | null;
      /**
       * Name
       * @description Name for new person (when target_person_id is None)
       */
      name?: string | null;
      /**
       * Protect Manual
       * @description If True, don't merge manually assigned clusters to different people
       * @default true
       */
      protect_manual?: boolean;
      /**
       * Facebank First
       * @description If True, try facebank matching before people prototypes (more accurate)
       * @default true
       */
      facebank_first?: boolean;
      /**
       * Execution Mode
       * @description Execution mode: 'redis' enqueues job via Celery, 'local' runs synchronously in-process
       * @default redis
       */
      execution_mode?: ("redis" | "local") | null;
    };
    /** HTTPValidationError */
    HTTPValidationError: {
      /** Detail */
      detail?: components["schemas"]["ValidationError"][];
    };
    /** IdentityMergeRequest */
    IdentityMergeRequest: {
      /** Source Id */
      source_id: string;
      /** Target Id */
      target_id: string;
    };
    /** IdentityNameRequest */
    IdentityNameRequest: {
      /** Name */
      name: string;
      /**
       * Show
       * @description Optional show slug override
       */
      show?: string | null;
    };
    /** IdentityRenameRequest */
    IdentityRenameRequest: {
      /** Label */
      label?: string | null;
    };
    /**
     * MatchRequest
     * @description Request to find matching archived items.
     */
    MatchRequest: {
      /**
       * Centroid
       * @description Face centroid embedding
       */
      centroid: number[];
      /**
       * Threshold
       * @description Minimum similarity threshold
       * @default 0.7
       */
      threshold?: number;
      /**
       * Item Type
       * @description Filter by type: person, cluster, track
       */
      item_type?: string | null;
    };
    /**
     * MergeAllRequest
     * @description Request to merge all high-similarity pairs.
     */
    MergeAllRequest: {
      /**
       * Similarity Threshold
       * @description Minimum similarity for auto-merge
       * @default 0.9
       */
      similarity_threshold?: number;
    };
    /**
     * MergeClustersRequest
     * @description Request to merge multiple clusters.
     */
    MergeClustersRequest: {
      /**
       * Cluster Ids
       * @description List of cluster IDs to merge
       */
      cluster_ids: string[];
      /**
       * Target Person Id
       * @description Optional person ID to merge into
       */
      target_person_id?: string | null;
    };
    /** MergeRequest */
    MergeRequest: {
      /** Source Id */
      source_id: string;
      /** Target Id */
      target_id: string;
    };
    /**
     * MirrorArtifactsRequest
     * @description Request to mirror specific artifacts from S3 to local storage.
     */
    MirrorArtifactsRequest: {
      /**
       * Artifacts
       * @default [
       *   "faces",
       *   "identities"
       * ]
       */
      artifacts?: string[];
    };
    /**
     * MirrorArtifactsResponse
     * @description Response from mirroring artifacts.
     */
    MirrorArtifactsResponse: {
      /** Ep Id */
      ep_id: string;
      /** Mirrored */
      mirrored: {
        [key: string]: boolean;
      };
      /** Errors */
      errors: {
        [key: string]: string;
      };
      /** Faces Manifest Exists */
      faces_manifest_exists: boolean;
      /** Identities Manifest Exists */
      identities_manifest_exists: boolean;
    };
    /** MoveTrackRequest */
    MoveTrackRequest: {
      /** Track Id */
      track_id: number;
      /**
       * Target Identity Id
       * @description Destination identity or null
       */
      target_identity_id?: string | null;
    };
    /**
     * ParallelJobRequest
     * @description Request model for running parallel jobs across multiple episodes.
     */
    ParallelJobRequest: {
      /**
       * Episode Ids
       * @description List of episode IDs to process
       */
      episode_ids: string[];
      /**
       * Operation
       * @description Operation to run: auto_group, refresh_similarity, manual_assign
       */
      operation: string;
      /**
       * Options
       * @description Options to pass to each task
       */
      options?: Record<string, never> | null;
    };
    /** PersonAddAliasRequest */
    PersonAddAliasRequest: {
      /** Alias */
      alias: string;
    };
    /** PersonCreateRequest */
    PersonCreateRequest: {
      /** Name */
      name?: string | null;
      /** Aliases */
      aliases?: string[] | null;
      /** Cast Id */
      cast_id?: string | null;
    };
    /** PersonMergeRequest */
    PersonMergeRequest: {
      /** Source Person Id */
      source_person_id: string;
      /** Target Person Id */
      target_person_id: string;
    };
    /** PersonResponse */
    PersonResponse: {
      /** Person Id */
      person_id: string;
      /** Show Id */
      show_id: string;
      /** Name */
      name: string | null;
      /**
       * Aliases
       * @default []
       */
      aliases?: string[];
      /** Prototype */
      prototype: number[];
      /** Cluster Ids */
      cluster_ids: string[];
      /** Rep Crop */
      rep_crop: string | null;
      /** Rep Crop S3 Key */
      rep_crop_s3_key?: string | null;
      /** Created At */
      created_at: string;
      /** Cast Id */
      cast_id?: string | null;
    };
    /** PersonUpdateRequest */
    PersonUpdateRequest: {
      /** Name */
      name?: string | null;
      /** Rep Crop */
      rep_crop?: string | null;
      /** Rep Crop S3 Key */
      rep_crop_s3_key?: string | null;
      /** Aliases */
      aliases?: string[] | null;
      /** Cast Id */
      cast_id?: string | null;
    };
    /** PhaseStatus */
    PhaseStatus: {
      /** Phase */
      phase: string;
      /** Status */
      status: string;
      /** Faces */
      faces?: number | null;
      /** Identities */
      identities?: number | null;
      /** Detections */
      detections?: number | null;
      /** Tracks */
      tracks?: number | null;
      /** Detector */
      detector?: string | null;
      /** Tracker */
      tracker?: string | null;
      /** Device */
      device?: string | null;
      /** Requested Device */
      requested_device?: string | null;
      /** Resolved Device */
      resolved_device?: string | null;
      /** Stride */
      stride?: number | null;
      /** Det Thresh */
      det_thresh?: number | null;
      /** Max Gap */
      max_gap?: number | null;
      /** Scene Threshold */
      scene_threshold?: number | null;
      /** Scene Min Len */
      scene_min_len?: number | null;
      /** Scene Warmup Dets */
      scene_warmup_dets?: number | null;
      /** Track High Thresh */
      track_high_thresh?: number | null;
      /** New Track Thresh */
      new_track_thresh?: number | null;
      /** Save Frames */
      save_frames?: boolean | null;
      /** Save Crops */
      save_crops?: boolean | null;
      /** Jpeg Quality */
      jpeg_quality?: number | null;
      /** Thumb Size */
      thumb_size?: number | null;
      /** Cluster Thresh */
      cluster_thresh?: number | null;
      /** Min Cluster Size */
      min_cluster_size?: number | null;
      /** Min Identity Sim */
      min_identity_sim?: number | null;
      /** Started At */
      started_at?: string | null;
      /** Finished At */
      finished_at?: string | null;
      /** Version */
      version?: string | null;
      /** Source */
      source?: string | null;
      /** Runtime Sec */
      runtime_sec?: number | null;
      /** Singleton Merge Enabled */
      singleton_merge_enabled?: boolean | null;
      /** Singleton Fraction Before */
      singleton_fraction_before?: number | null;
      /** Singleton Fraction After */
      singleton_fraction_after?: number | null;
      /** Singleton Merge Neighbor Top K */
      singleton_merge_neighbor_top_k?: number | null;
      /** Singleton Merge Merge Count */
      singleton_merge_merge_count?: number | null;
      /** Singleton Merge Similarity Thresh */
      singleton_merge_similarity_thresh?: number | null;
      /** Singleton Stats */
      singleton_stats?: Record<string, never> | null;
      /** Manifest Exists */
      manifest_exists?: boolean | null;
      /** Zero Rows */
      zero_rows?: boolean | null;
      /** Last Run At */
      last_run_at?: string | null;
      /** Track Metrics Exists */
      track_metrics_exists?: boolean | null;
    };
    /**
     * PresenceHeartbeat
     * @description Request body for presence heartbeat.
     */
    PresenceHeartbeat: {
      /**
       * User Id
       * @description User identifier
       */
      user_id?: string | null;
      /**
       * User Name
       * @description Display name
       * @default Anonymous
       */
      user_name?: string | null;
    };
    /** PurgeAllLegacyIn */
    PurgeAllLegacyIn: {
      /** Confirm */
      confirm: string;
      /**
       * Delete Artifacts
       * @default true
       */
      delete_artifacts?: boolean;
      /**
       * Delete Raw
       * @default false
       */
      delete_raw?: boolean;
      /**
       * Delete Local
       * @default true
       */
      delete_local?: boolean;
    };
    /**
     * RefreshSimilarityRequest
     * @description Request model for similarity refresh with optional execution mode.
     */
    RefreshSimilarityRequest: {
      /**
       * Execution Mode
       * @description Execution mode: 'redis' enqueues job via Celery, 'local' runs synchronously in-process
       * @default redis
       */
      execution_mode?: ("redis" | "local") | null;
    };
    /** RenameRequest */
    RenameRequest: {
      /**
       * Identity Id
       * @description Identity to rename
       */
      identity_id: string;
      /**
       * New Label
       * @description New label
       */
      new_label?: string | null;
    };
    /** S3EpisodeForShow */
    S3EpisodeForShow: {
      /** Ep Id */
      ep_id: string;
      /** Season */
      season: number;
      /** Episode */
      episode: number;
      /** Key */
      key: string;
      /** Exists In Store */
      exists_in_store: boolean;
    };
    /** S3EpisodesForShowResponse */
    S3EpisodesForShowResponse: {
      /** Show */
      show: string;
      /** Episodes */
      episodes: components["schemas"]["S3EpisodeForShow"][];
      /** Count */
      count: number;
    };
    /** S3Show */
    S3Show: {
      /** Show */
      show: string;
      /** Episode Count */
      episode_count: number;
    };
    /** S3ShowsResponse */
    S3ShowsResponse: {
      /** Shows */
      shows: components["schemas"]["S3Show"][];
      /** Count */
      count: number;
    };
    /** S3VideoItem */
    S3VideoItem: {
      /** Bucket */
      bucket: string;
      /** Key */
      key: string;
      /** Ep Id */
      ep_id: string;
      /** Show */
      show?: string | null;
      /** Season */
      season?: number | null;
      /** Episode */
      episode?: number | null;
      /** Size */
      size?: number | null;
      /** Last Modified */
      last_modified?: string | null;
      /** Etag */
      etag?: string | null;
      /** Exists In Store */
      exists_in_store: boolean;
      /** Key Version */
      key_version?: string | null;
    };
    /** S3VideosResponse */
    S3VideosResponse: {
      /** Items */
      items: components["schemas"]["S3VideoItem"][];
      /** Count */
      count: number;
    };
    /** ShowCreateRequest */
    ShowCreateRequest: {
      /**
       * Show Id
       * @description Unique show identifier (slug)
       */
      show_id: string;
      /**
       * Title
       * @description Short display name
       */
      title?: string | null;
      /**
       * Full Name
       * @description Full/legal show name
       */
      full_name?: string | null;
      /**
       * Imdb Series Id
       * @description IMDb series identifier (e.g., tt2861424)
       */
      imdb_series_id?: string | null;
    };
    /** ShowEntry */
    ShowEntry: {
      /** Show Id */
      show_id: string;
      /** Title */
      title?: string | null;
      /** Full Name */
      full_name?: string | null;
      /** Imdb Series Id */
      imdb_series_id?: string | null;
      /** Cast Count */
      cast_count: number;
    };
    /** ShowListResponse */
    ShowListResponse: {
      /** Shows */
      shows: components["schemas"]["ShowEntry"][];
      /** Count */
      count: number;
    };
    /** ShowRegistrationResponse */
    ShowRegistrationResponse: {
      /** Show Id */
      show_id: string;
      /** Title */
      title?: string | null;
      /** Full Name */
      full_name?: string | null;
      /** Imdb Series Id */
      imdb_series_id?: string | null;
      /** Cast Count */
      cast_count: number;
      /** Created */
      created: boolean;
    };
    /** TrackDeleteRequest */
    TrackDeleteRequest: {
      /**
       * Delete Faces
       * @default true
       */
      delete_faces?: boolean;
    };
    /** TrackFrameDeleteRequest */
    TrackFrameDeleteRequest: {
      /**
       * Frame Ids
       * @description Track frame indices to delete
       */
      frame_ids: number[];
      /**
       * Delete Assets
       * @default true
       */
      delete_assets?: boolean;
    };
    /** TrackFrameMoveRequest */
    TrackFrameMoveRequest: {
      /**
       * Frame Ids
       * @description Track frame indices to move
       */
      frame_ids: number[];
      /**
       * Target Identity Id
       * @description Existing identity target
       */
      target_identity_id?: string | null;
      /**
       * New Identity Name
       * @description Optional new identity name
       */
      new_identity_name?: string | null;
      /**
       * Show Id
       * @description Optional show slug override
       */
      show_id?: string | null;
    };
    /** TrackMoveRequest */
    TrackMoveRequest: {
      /** Target Identity Id */
      target_identity_id?: string | null;
    };
    /** TrackRequest */
    TrackRequest: {
      /**
       * Ep Id
       * @description Episode identifier
       */
      ep_id: string;
    };
    /** ValidationError */
    ValidationError: {
      /** Location */
      loc: (string | number)[];
      /** Message */
      msg: string;
      /** Error Type */
      type: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /**
   * List Episodes
   * @description List all episodes.
   *
   * Show slugs are normalized to UPPERCASE for consistent display.
   */
  list_episodes_episodes_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["EpisodeListResponse"];
        };
      };
    };
  };
  /** Create Episode */
  create_episode_episodes_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["EpisodeCreateRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["EpisodeCreateResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** List S3 Videos */
  list_s3_videos_episodes_s3_videos_get: {
    parameters: {
      query?: {
        q?: string | null;
        limit?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["S3VideosResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List S3 Shows
   * @description List all shows available in S3 with episode counts.
   *
   * Show codes are normalized to UPPERCASE and deduplicated case-insensitively.
   */
  list_s3_shows_episodes_s3_shows_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["S3ShowsResponse"];
        };
      };
    };
  };
  /**
   * List S3 Episodes For Show
   * @description List all episodes for a specific show from S3.
   */
  list_s3_episodes_for_show_episodes_s3_shows__show__episodes_get: {
    parameters: {
      path: {
        show: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["S3EpisodesForShowResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Delete Episode New */
  delete_episode_new_episodes__ep_id__delete_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["DeleteEpisodeIn"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Delete All */
  delete_all_episodes_delete_all_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DeleteAllIn"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Episode Details */
  episode_details_episodes__ep_id__get: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["EpisodeDetailResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Delete Episode */
  delete_episode_episodes__ep_id__delete: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["DeleteEpisodeLegacyIn"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Purge All */
  purge_all_episodes_purge_all_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["PurgeAllLegacyIn"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Episode Progress */
  episode_progress_episodes__ep_id__progress_get: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Episode Run Status */
  episode_run_status_episodes__ep_id__status_get: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["EpisodeStatusResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Episode Events */
  episode_events_episodes__ep_id__events_get: {
    parameters: {
      query?: {
        poll_ms?: number;
        max_events?: number;
      };
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Upsert By Id */
  upsert_by_id_episodes_upsert_by_id_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["EpisodeUpsert"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Presign Episode Assets */
  presign_episode_assets_episodes__ep_id__assets_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["AssetUploadResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Mirror Episode Video */
  mirror_episode_video_episodes__ep_id__mirror_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["EpisodeMirrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Hydrate Episode Video */
  hydrate_episode_video_episodes__ep_id__hydrate_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["EpisodeMirrorResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Mirror Episode Artifacts
   * @description Mirror faces/identities artifacts from S3 to local storage.
   *
   * This endpoint downloads manifest files (faces.jsonl, identities.json) from S3
   * to the local file system, enabling clustering operations on machines that
   * don't have direct S3 access or need local copies.
   *
   * Unlike /mirror which only mirrors the video, this mirrors the pipeline artifacts.
   */
  mirror_episode_artifacts_episodes__ep_id__mirror_artifacts_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["MirrorArtifactsRequest"] | null;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["MirrorArtifactsResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Refresh Similarity Values
   * @description Recompute all similarity scores for the episode.
   *
   * This regenerates track representatives, cluster centroids, updates
   * all similarity scores, and refreshes suggestions for unassigned clusters.
   *
   * Returns detailed step-by-step progress log with stats.
   */
  refresh_similarity_values_episodes__ep_id__refresh_similarity_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Refresh Similarity Async
   * @description Enqueue similarity refresh as background job (non-blocking).
   *
   * Execution Mode:
   *     - execution_mode="redis" (default): Enqueues job via Celery, returns 202 with job_id
   *     - execution_mode="local": Runs job synchronously in-process, returns result when done
   *
   * If Celery/Redis are unavailable in redis mode, returns an error.
   */
  refresh_similarity_async_episodes__ep_id__refresh_similarity_async_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["RefreshSimilarityRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      202: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Recover Noise Tracks Preview
   * @description Preview what would change if recovery were run (without making changes).
   *
   * Returns counts of single-frame tracks and estimated recoverable tracks.
   */
  recover_noise_tracks_preview_episodes__ep_id__recover_noise_tracks_preview_get: {
    parameters: {
      query?: {
        /** @description Number of frames to search before/after */
        frame_window?: number;
        /** @description Minimum cosine similarity to merge */
        min_similarity?: number;
      };
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Recover Noise Tracks
   * @description Recover single-frame tracks by finding similar faces in adjacent frames.
   *
   * For each track that has only 1 face (single-frame track):
   * 1. Searches ±frame_window frames for similar faces (cosine similarity >= min_similarity)
   * 2. Merges matching faces into the single-frame track
   * 3. Updates faces.jsonl and tracks.jsonl with new assignments
   *
   * This helps convert "noise" clusters (single-frame-only) into reviewable clusters.
   *
   * Args:
   *     frame_window: Number of frames to search before/after (default: 8)
   *     min_similarity: Minimum cosine similarity to merge faces (default: 0.70)
   *
   * Returns:
   *     tracks_analyzed: Number of single-frame tracks examined
   *     tracks_expanded: Number of tracks that were expanded
   *     faces_merged: Total faces added to tracks
   *     details: List of {track_id, original_frame, added_frames}
   */
  recover_noise_tracks_episodes__ep_id__recover_noise_tracks_post: {
    parameters: {
      query?: {
        /** @description Number of frames to search before/after */
        frame_window?: number;
        /** @description Minimum cosine similarity to merge */
        min_similarity?: number;
      };
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Episode Video Meta */
  episode_video_meta_episodes__ep_id__video_meta_get: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["EpisodeVideoMeta"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** List Identities */
  list_identities_episodes__ep_id__identities_get: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** List Cluster Tracks */
  list_cluster_tracks_episodes__ep_id__cluster_tracks_get: {
    parameters: {
      query?: {
        /** @description Optional max tracks per cluster */
        limit_per_cluster?: number | null;
      };
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Cluster Track Reps
   * @description Get representative frames with similarity scores for all tracks in a cluster.
   */
  get_cluster_track_reps_episodes__ep_id__clusters__cluster_id__track_reps_get: {
    parameters: {
      path: {
        ep_id: string;
        cluster_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Person Clusters Summary
   * @description Get clusters summary with track representatives for a person in an episode.
   */
  get_person_clusters_summary_episodes__ep_id__people__person_id__clusters_summary_get: {
    parameters: {
      path: {
        ep_id: string;
        person_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Faces Grid */
  faces_grid_episodes__ep_id__faces_grid_get: {
    parameters: {
      query?: {
        track_id?: number | null;
      };
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Identity Detail */
  identity_detail_episodes__ep_id__identities__identity_id__get: {
    parameters: {
      path: {
        ep_id: string;
        identity_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Delete Identity
   * @description Delete (archive) an identity/cluster.
   *
   * The cluster is moved to the archive where its centroid is stored.
   * This allows matching faces in future episodes to be auto-archived.
   */
  delete_identity_episodes__ep_id__identities__identity_id__delete: {
    parameters: {
      path: {
        ep_id: string;
        identity_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Track Detail */
  track_detail_episodes__ep_id__tracks__track_id__get: {
    parameters: {
      path: {
        ep_id: string;
        track_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Delete Track */
  delete_track_episodes__ep_id__tracks__track_id__delete: {
    parameters: {
      path: {
        ep_id: string;
        track_id: number;
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["TrackDeleteRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** List Track Crops */
  list_track_crops_episodes__ep_id__tracks__track_id__crops_get: {
    parameters: {
      query?: {
        /** @description Return every Nth crop */
        sample?: number;
        limit?: number;
        /** @description Opaque cursor returned by the previous call */
        start_after?: string | null;
      };
      path: {
        ep_id: string;
        track_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** List Track Frames */
  list_track_frames_episodes__ep_id__tracks__track_id__frames_get: {
    parameters: {
      query?: {
        /** @description Return every Nth frame */
        sample?: number;
        page?: number;
        page_size?: number;
      };
      path: {
        ep_id: string;
        track_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Delete Track Frames */
  delete_track_frames_episodes__ep_id__tracks__track_id__frames_delete: {
    parameters: {
      path: {
        ep_id: string;
        track_id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TrackFrameDeleteRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Track Integrity */
  track_integrity_episodes__ep_id__tracks__track_id__integrity_get: {
    parameters: {
      path: {
        ep_id: string;
        track_id: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Move Track Frames */
  move_track_frames_episodes__ep_id__tracks__track_id__frames_move_post: {
    parameters: {
      path: {
        ep_id: string;
        track_id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TrackFrameMoveRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Rename Identity */
  rename_identity_episodes__ep_id__identities__identity_id__rename_post: {
    parameters: {
      path: {
        ep_id: string;
        identity_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["IdentityRenameRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Assign Identity Name */
  assign_identity_name_episodes__ep_id__identities__identity_id__name_post: {
    parameters: {
      path: {
        ep_id: string;
        identity_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["IdentityNameRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Assign Track Name */
  assign_track_name_episodes__ep_id__tracks__track_id__name_post: {
    parameters: {
      path: {
        ep_id: string;
        track_id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["IdentityNameRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Bulk Assign Tracks
   * @description Bulk assign multiple tracks to a cast member by name.
   *
   * This creates or updates identity assignments for each track, similar to
   * calling assign_track_name for each track individually but more efficient.
   */
  bulk_assign_tracks_episodes__ep_id__tracks_bulk_assign_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["BulkTrackAssignRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Merge Identities */
  merge_identities_episodes__ep_id__identities_merge_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["IdentityMergeRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Move Track */
  move_track_episodes__ep_id__tracks__track_id__move_post: {
    parameters: {
      path: {
        ep_id: string;
        track_id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TrackMoveRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Move Faces */
  move_faces_episodes__ep_id__faces_move_frames_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["FaceMoveRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Generate Frame Overlay
   * @description Generate a full-frame image with bounding boxes for all faces in that frame.
   *
   * This extracts the frame from the video, draws colored bounding boxes for each
   * track present in that frame, and saves the result as an overlay image.
   *
   * Returns:
   *     {
   *         "url": "path/to/overlay.jpg",
   *         "frame_idx": 804,
   *         "tracks": [{"track_id": 1, "bbox": [x1,y1,x2,y2]}, ...]
   *     }
   */
  generate_frame_overlay_episodes__ep_id__frames__frame_idx__overlay_post: {
    parameters: {
      path: {
        ep_id: string;
        frame_idx: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Delete Frame */
  delete_frame_episodes__ep_id__frames_delete: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["FrameDeleteRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Export Facebank Seeds
   * @description Select and export high-quality seed frames to permanent facebank.
   * Only exports user-confirmed identities with person_id mappings.
   */
  export_facebank_seeds_episodes__ep_id__identities__identity_id__export_seeds_post: {
    parameters: {
      path: {
        ep_id: string;
        identity_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Presence
   * @description Get current viewers for an episode.
   *
   * Returns list of users currently viewing this episode,
   * excluding viewers whose heartbeat has expired.
   */
  get_presence_episodes__ep_id__presence_get: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Update Presence
   * @description Update presence heartbeat for a user viewing an episode.
   *
   * Call this endpoint periodically (every 30s) to maintain presence.
   */
  update_presence_episodes__ep_id__presence_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["PresenceHeartbeat"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Leave Presence
   * @description Remove presence for a user (when leaving the page).
   */
  leave_presence_episodes__ep_id__presence_delete: {
    parameters: {
      query?: {
        user_id?: string | null;
      };
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Rename Identity */
  rename_identity_identities__ep_id__rename_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RenameRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Merge Identities */
  merge_identities_identities__ep_id__merge_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["MergeRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Move Track */
  move_track_identities__ep_id__move_track_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["MoveTrackRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Drop Track */
  drop_track_identities__ep_id__drop_track_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["DropTrackRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Drop Frame */
  drop_frame_identities__ep_id__drop_frame_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["DropFrameRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get Roster */
  get_roster_shows__show__roster_get: {
    parameters: {
      path: {
        show: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Add Roster Name */
  add_roster_name_shows__show__roster_names_post: {
    parameters: {
      path: {
        show: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CastNameRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** List Cast Names */
  list_cast_names_shows__show__cast_names_get: {
    parameters: {
      path: {
        show: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Add Cast Name */
  add_cast_name_shows__show__cast_names_post: {
    parameters: {
      path: {
        show: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CastNameRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** List Registered Shows */
  list_registered_shows_shows_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ShowListResponse"];
        };
      };
    };
  };
  /** Register Show */
  register_show_shows_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ShowCreateRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ShowRegistrationResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List Cast
   * @description Get all cast members for a show, optionally filtered by season.
   */
  list_cast_shows__show_id__cast_get: {
    parameters: {
      query?: {
        season?: string | null;
        /** @description Include featured thumbnail URLs sourced from facebank */
        include_featured?: boolean;
      };
      path: {
        show_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Create Cast Member
   * @description Create a new cast member.
   */
  create_cast_member_shows__show_id__cast_post: {
    parameters: {
      path: {
        show_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CastMemberCreateRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["CastMemberResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Cast Member
   * @description Get a specific cast member.
   */
  get_cast_member_shows__show_id__cast__cast_id__get: {
    parameters: {
      path: {
        show_id: string;
        cast_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["CastMemberResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Delete Cast Member
   * @description Delete a cast member.
   */
  delete_cast_member_shows__show_id__cast__cast_id__delete: {
    parameters: {
      path: {
        show_id: string;
        cast_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Update Cast Member
   * @description Update a cast member.
   */
  update_cast_member_shows__show_id__cast__cast_id__patch: {
    parameters: {
      path: {
        show_id: string;
        cast_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CastMemberUpdateRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["CastMemberResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Bulk Import Cast
   * @description Bulk import cast members.
   *
   * Members with matching names (case-insensitive) will be updated unless force_new=true.
   *
   * Example JSON:
   * {
   *   "members": [
   *     {
   *       "name": "Kyle Richards",
   *       "role": "main",
   *       "status": "active",
   *       "aliases": ["Kyle", "Kyle R"],
   *       "seasons": ["S01", "S02", "S03"]
   *     }
   *   ],
   *   "force_new": false
   * }
   */
  bulk_import_cast_shows__show_id__cast_import_post: {
    parameters: {
      path: {
        show_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["BulkImportRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Facebank
   * @description Get facebank data for a cast member.
   */
  get_facebank_cast__cast_id__facebank_get: {
    parameters: {
      query: {
        show_id: string;
      };
      path: {
        cast_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["FacebankResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Upload Seeds
   * @description Upload seed images for a cast member.
   */
  upload_seeds_cast__cast_id__seeds_upload_post: {
    parameters: {
      query: {
        show_id: string;
      };
      path: {
        cast_id: string;
      };
    };
    requestBody: {
      content: {
        "multipart/form-data": components["schemas"]["Body_upload_seeds_cast__cast_id__seeds_upload_post"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Delete Seeds
   * @description Delete seed images from a cast member's facebank.
   */
  delete_seeds_cast__cast_id__seeds_delete: {
    parameters: {
      query: {
        show_id: string;
      };
      path: {
        cast_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["DeleteSeedsRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Feature Seed
   * @description Mark a seed as the featured facebank image.
   */
  feature_seed_cast__cast_id__seeds__seed_id__feature_post: {
    parameters: {
      query: {
        show_id: string;
      };
      path: {
        cast_id: string;
        seed_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["FeatureSeedResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Seed Image
   * @description Serve a seed image file (fallback for local storage without S3).
   */
  get_seed_image_cast__cast_id__seeds__seed_id__image_get: {
    parameters: {
      query: {
        show_id: string;
      };
      path: {
        cast_id: string;
        seed_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Presign Image
   * @description Generate a presigned URL for an S3 object with proper content-type headers.
   */
  presign_image_files_presign_get: {
    parameters: {
      query: {
        /** @description S3 object key */
        key: string;
        /** @description Content type override */
        mime?: string | null;
        /** @description URL expiration in seconds */
        ttl?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Check Image Health
   * @description Check if an image exists and is accessible, with optional image diagnostics.
   */
  check_image_health_files_health_get: {
    parameters: {
      query: {
        /** @description Local path or S3 key */
        path_or_key: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Check Detector Health
   * @description Check RetinaFace detector availability and status.
   */
  check_detector_health_health_detector_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
    };
  };
  /**
   * Backfill Facebank Display
   * @description Regenerate missing or low-resolution facebank display derivatives.
   */
  backfill_facebank_display_jobs_jobs_facebank_backfill_display_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["FacebankBackfillRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Enqueue Detect */
  enqueue_detect_jobs_detect_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DetectRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Enqueue Track */
  enqueue_track_jobs_track_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["TrackRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Run Detect Track */
  run_detect_track_jobs_detect_track_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DetectTrackRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Run Faces Embed */
  run_faces_embed_jobs_faces_embed_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["FacesEmbedRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Run Cluster */
  run_cluster_jobs_cluster_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ClusterRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Enqueue Detect Track Async */
  enqueue_detect_track_async_jobs_detect_track_async_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DetectTrackRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Enqueue Faces Embed Async */
  enqueue_faces_embed_async_jobs_faces_embed_async_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["FacesEmbedRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Enqueue Cluster Async */
  enqueue_cluster_async_jobs_cluster_async_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ClusterRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Enqueue Episode Cleanup Async */
  enqueue_episode_cleanup_async_jobs_episode_cleanup_async_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CleanupJobRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Analyze Screen Time
   * @description Analyze per-cast screen time from assigned faces and tracks.
   */
  analyze_screen_time_jobs_screen_time_analyze_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["AnalyzeScreenTimeRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List Jobs
   * @description List all jobs, optionally filtered by episode and/or job type.
   */
  list_jobs_jobs_get: {
    parameters: {
      query?: {
        ep_id?: string | null;
        job_type?: string | null;
        limit?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get Job Progress */
  get_job_progress_jobs__job_id__progress_get: {
    parameters: {
      path: {
        job_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Job Details */
  job_details_jobs__job_id__get: {
    parameters: {
      path: {
        job_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Cancel Job */
  cancel_job_jobs__job_id__cancel_post: {
    parameters: {
      path: {
        job_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List People
   * @description Get all people for a show.
   */
  list_people_shows__show_id__people_get: {
    parameters: {
      path: {
        show_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Create Person
   * @description Create a new person.
   */
  create_person_shows__show_id__people_post: {
    parameters: {
      path: {
        show_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PersonCreateRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PersonResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Person
   * @description Get a specific person.
   */
  get_person_shows__show_id__people__person_id__get: {
    parameters: {
      path: {
        show_id: string;
        person_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PersonResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Delete Person
   * @description Delete (archive) a person.
   *
   * The person is moved to the archive where their centroid is stored.
   * This allows matching faces in future episodes to be auto-archived.
   */
  delete_person_shows__show_id__people__person_id__delete: {
    parameters: {
      path: {
        show_id: string;
        person_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Update Person
   * @description Update a person.
   */
  update_person_shows__show_id__people__person_id__patch: {
    parameters: {
      path: {
        show_id: string;
        person_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PersonUpdateRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PersonResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Merge People
   * @description Merge source person into target person.
   */
  merge_people_shows__show_id__people_merge_post: {
    parameters: {
      path: {
        show_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PersonMergeRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PersonResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Add Alias
   * @description Add an alias to a person.
   */
  add_alias_shows__show_id__people__person_id__add_alias_post: {
    parameters: {
      path: {
        show_id: string;
        person_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PersonAddAliasRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PersonResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Group Clusters
   * @description Group clusters either automatically or manually.
   *
   * Auto mode: Compute centroids, run within-episode grouping, then across-episode matching.
   * Manual mode: Assign specific clusters to a person (new or existing).
   */
  group_clusters_episodes__ep_id__clusters_group_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["GroupClustersRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Batch Assign Clusters
   * @description Batch assign multiple clusters to cast members in a single operation.
   *
   * This endpoint is optimized for bulk assignments - it loads data once and
   * processes all assignments together, significantly reducing latency compared
   * to multiple individual calls.
   *
   * Request body:
   *     assignments: List of {cluster_id, target_cast_id} pairs
   *
   * Returns:
   *     - status: "success" or "partial" (if some failed)
   *     - results: List of assignment results
   *     - succeeded: Count of successful assignments
   *     - failed: Count of failed assignments
   */
  batch_assign_clusters_episodes__ep_id__clusters_batch_assign_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["BatchAssignRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Batch Assign Clusters Async
   * @description Enqueue batch cluster assignment as background job (non-blocking).
   *
   * Execution Mode:
   *     - execution_mode="redis" (default): Enqueues job via Celery, returns 202 with job_id
   *     - execution_mode="local": Runs job synchronously in-process, returns result when done
   *
   * If Celery/Redis are unavailable, falls back to synchronous execution.
   */
  batch_assign_clusters_async_episodes__ep_id__clusters_batch_assign_async_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["BatchAssignRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      202: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Group Clusters Async
   * @description Enqueue auto-grouping as background job (non-blocking).
   *
   * Execution Mode:
   *     - execution_mode="redis" (default): Enqueues job via Celery, returns 202 with job_id
   *     - execution_mode="local": Runs job synchronously in-process, returns result when done
   *
   * Only supports strategy="auto". For manual/facebank, use the synchronous endpoint.
   * If Celery/Redis are unavailable, falls back to synchronous execution.
   */
  group_clusters_async_episodes__ep_id__clusters_group_async_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["GroupClustersRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      202: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Group Clusters Progress
   * @description Return in-flight grouping progress for polling clients.
   */
  group_clusters_progress_episodes__ep_id__clusters_group_progress_get: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Cluster Centroids
   * @description Get cluster centroids for an episode.
   */
  get_cluster_centroids_episodes__ep_id__cluster_centroids_get: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Compute Cluster Centroids
   * @description Compute cluster centroids for an episode.
   */
  compute_cluster_centroids_episodes__ep_id__cluster_centroids_compute_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Cluster Suggestions
   * @description Get suggested cast member matches for episode clusters.
   *
   * Returns suggestions based on similarity to existing people without actually assigning.
   */
  get_cluster_suggestions_episodes__ep_id__cluster_suggestions_get: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Cluster Suggestions From Assigned
   * @description Get suggested matches for unassigned clusters by comparing with assigned clusters.
   *
   * Compares unassigned cluster centroids against assigned cluster centroids in the same episode.
   * Returns suggestions based on which assigned person has the most similar cluster.
   */
  get_cluster_suggestions_from_assigned_episodes__ep_id__cluster_suggestions_from_assigned_get: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Suggest Cast For Cluster
   * @description Get cast member suggestions for a specific cluster (Enhancement #6).
   *
   * Compares the cluster's centroid against all cast member facebank seeds.
   * Returns top-k cast member suggestions with confidence levels.
   *
   * This endpoint is designed for on-demand "Suggest for Me" button clicks.
   */
  suggest_cast_for_cluster_episodes__ep_id__clusters__cluster_id__suggest_cast_get: {
    parameters: {
      query?: {
        min_similarity?: number;
        top_k?: number;
      };
      path: {
        ep_id: string;
        cluster_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Cast Suggestions
   * @description Get cast member suggestions for unassigned clusters based on facebank similarity.
   *
   * Compares each unassigned cluster's centroid against all cast member facebank seeds.
   * Returns top-k cast member suggestions per cluster with confidence levels.
   *
   * Query params:
   *     min_similarity: Minimum similarity threshold (default 0.50)
   *     top_k: Number of suggestions per cluster (default 3)
   */
  get_cast_suggestions_episodes__ep_id__cast_suggestions_get: {
    parameters: {
      query?: {
        min_similarity?: number;
        top_k?: number;
      };
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List Unlinked Entities
   * @description Return clusters that are not linked to a cast member (auto-people + unassigned clusters).
   */
  list_unlinked_entities_episodes__ep_id__unlinked_entities_get: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Auto Link Cast
   * @description Auto-assign unassigned clusters to cast members with high confidence (Enhancement #8).
   *
   * Only assigns when facebank similarity is >= min_confidence.
   * Called during Refresh Values to auto-link obvious matches.
   */
  auto_link_cast_episodes__ep_id__auto_link_cast_post: {
    parameters: {
      query?: {
        min_confidence?: number;
      };
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Cleanup Preview
   * @description Get a preview of what would change if cleanup were run (Enhancement #3).
   *
   * Analyzes current state and estimates impact without making changes.
   * Returns counts of affected clusters, manual assignments that could be impacted, etc.
   */
  cleanup_preview_episodes__ep_id__cleanup_preview_get: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Create Backup
   * @description Create backup before cleanup (Enhancement #7).
   *
   * Backs up identities.json, people.json, cluster_centroids.json.
   */
  create_backup_episodes__ep_id__backup_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Restore Backup
   * @description Restore from a backup (Enhancement #7).
   */
  restore_backup_episodes__ep_id__restore__backup_id__post: {
    parameters: {
      path: {
        ep_id: string;
        backup_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List Backups
   * @description List available backups for an episode (Enhancement #7).
   */
  list_backups_episodes__ep_id__backups_get: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Cross Episode Consistency
   * @description Check for cross-episode inconsistencies (Enhancement #9).
   *
   * Finds clusters that might be the same person but are assigned differently.
   */
  cross_episode_consistency_episodes__ep_id__consistency_check_get: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Save Assignments
   * @description Save all current cluster assignments to people.json and identities.json.
   *
   * This ensures all assignments made in the UI are persisted.
   */
  save_assignments_episodes__ep_id__save_assignments_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Undo Stack
   * @description Get the undo stack for an episode.
   *
   * Returns list of operations that can be undone, with id, type, description, timestamp.
   */
  get_undo_stack_episodes__ep_id__undo_stack_get: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Undo Last Operation
   * @description Undo the last operation for an episode.
   *
   * Restores the state before the last undoable operation.
   */
  undo_last_operation_episodes__ep_id__undo_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Tiered Suggestions
   * @description Get cast suggestions tiered by confidence level.
   *
   * Returns suggestions in three tiers:
   * - high_confidence: Auto-assignable (≥85% similarity)
   * - medium_confidence: Review queue (68-85% similarity)
   * - low_confidence: Manual review required (<68% similarity)
   */
  get_tiered_suggestions_episodes__ep_id__tiered_suggestions_get: {
    parameters: {
      query?: {
        high_threshold?: number;
        medium_threshold?: number;
      };
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Auto Assign High Confidence
   * @description Auto-assign all high-confidence suggestions.
   *
   * Automatically assigns clusters to cast members when similarity exceeds threshold.
   *
   * Args:
   *     threshold: Minimum similarity for auto-assignment (default 0.85)
   */
  auto_assign_high_confidence_episodes__ep_id__auto_assign_high_confidence_post: {
    parameters: {
      query?: {
        threshold?: number;
      };
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Potential Duplicates
   * @description Find clusters that might be duplicates (same person split across clusters).
   *
   * Returns pairs of clusters that exceed the similarity threshold.
   */
  get_potential_duplicates_episodes__ep_id__potential_duplicates_get: {
    parameters: {
      query?: {
        similarity_threshold?: number;
        max_pairs?: number;
      };
      path: {
        ep_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Merge Clusters
   * @description Merge multiple clusters into a single person.
   *
   * Args:
   *     cluster_ids: List of cluster IDs to merge
   *     target_person_id: Optional person ID to merge into (creates new if not provided)
   */
  merge_clusters_episodes__ep_id__merge_clusters_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["MergeClustersRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Merge All Duplicates
   * @description Automatically merge all high-similarity cluster pairs.
   *
   * Uses transitive closure to group connected clusters before merging.
   *
   * Args:
   *     similarity_threshold: Minimum similarity for auto-merge (default 0.90)
   */
  merge_all_duplicates_episodes__ep_id__merge_all_duplicates_post: {
    parameters: {
      path: {
        ep_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["MergeAllRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Read Show
   * @description Return show metadata from core.shows.
   *
   * Args:
   *     show_slug: Show identifier (e.g., 'RHOBH', 'RHOSLC')
   *
   * Returns:
   *     JSON object with show fields:
   *     - show_id: Primary key
   *     - show_slug: Show identifier
   *     - title: Display name
   *     - franchise: Franchise name (nullable)
   *     - network: Network name (nullable)
   *     - imdb_series_id: IMDb series ID (nullable)
   *     - tmdb_series_id: TMDb series ID (nullable)
   *     - is_active: Whether show is currently active
   *
   * Raises:
   *     HTTPException: 404 if show not found
   *     HTTPException: 500 if database connection or query fails
   */
  read_show_metadata_shows__show_slug__get: {
    parameters: {
      path: {
        show_slug: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Read Show Seasons
   * @description Return seasons for a show from core.seasons.
   *
   * Args:
   *     show_slug: Show identifier (e.g., 'RHOBH', 'RHOSLC')
   *
   * Returns:
   *     JSON object with:
   *     - show: Show metadata object
   *     - seasons: Array of season objects with fields:
   *       - season_id: Primary key
   *       - show_id: Foreign key to show
   *       - season_number: Season number
   *       - label: Display label (nullable)
   *       - is_current: Whether this is the current season
   *
   * Raises:
   *     HTTPException: 404 if show not found
   *     HTTPException: 500 if database connection or query fails
   */
  read_show_seasons_metadata_shows__show_slug__seasons_get: {
    parameters: {
      path: {
        show_slug: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Read Show Episodes
   * @description Return episodes for a show from core.episodes.
   *
   * Args:
   *     show_slug: Show identifier (e.g., 'RHOBH', 'RHOSLC')
   *
   * Returns:
   *     JSON object with:
   *     - show: Show metadata object
   *     - episodes: Array of episode objects with fields:
   *       - episode_id: Primary key
   *       - season_id: Foreign key to season
   *       - season_number: Season number (from join)
   *       - episode_number: Episode number within season
   *       - episode_code: Episode code (nullable, e.g. "S01E01")
   *       - title: Episode title (nullable)
   *       - air_date: Air date (nullable)
   *       - runtime_seconds: Runtime in seconds (nullable)
   *
   * Raises:
   *     HTTPException: 404 if show not found
   *     HTTPException: 500 if database connection or query fails
   */
  read_show_episodes_metadata_shows__show_slug__episodes_get: {
    parameters: {
      path: {
        show_slug: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Read Show Cast
   * @description Return the canonical cast list for a given show slug from core.cast.
   *
   * Args:
   *     show_slug: Show identifier (e.g., 'RHOBH', 'RHOSLC')
   *
   * Returns:
   *     JSON array of cast member records with fields:
   *     - cast_id: Primary key (text or UUID)
   *     - show_slug: Show identifier
   *     - person_name: Cast member's name
   *     - imdb_person_id: IMDb person ID (nullable)
   *     - tmdb_person_id: TMDb person ID (nullable)
   *     - bravo_cast_slug: Stable UI slug (nullable)
   *     - sort_order: Display order hint (nullable)
   *
   * Raises:
   *     HTTPException: 404 if no cast found for the show
   *     HTTPException: 500 if database connection or query fails
   */
  read_show_cast_metadata_shows__show_slug__cast_get: {
    parameters: {
      path: {
        show_slug: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List Archived Items
   * @description List archived items for a show.
   *
   * Returns paginated list of archived people, clusters, and tracks.
   */
  list_archived_items_archive_shows__show_id__get: {
    parameters: {
      query?: {
        /** @description Filter: person, cluster, track */
        item_type?: string | null;
        /** @description Filter by episode */
        episode_id?: string | null;
        limit?: number;
        offset?: number;
      };
      path: {
        show_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Archive Stats
   * @description Get archive statistics for a show.
   */
  get_archive_stats_archive_shows__show_id__stats_get: {
    parameters: {
      path: {
        show_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Find Matching Archived
   * @description Find archived items matching a given face centroid.
   *
   * Used to check if a new face matches previously archived (rejected) faces.
   */
  find_matching_archived_archive_shows__show_id__match_post: {
    parameters: {
      path: {
        show_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["MatchRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Restore Archived Item
   * @description Restore an archived person.
   *
   * Returns the original person data. The caller should use this
   * to recreate the person via the people API.
   */
  restore_archived_item_archive_shows__show_id__restore__archive_id__post: {
    parameters: {
      path: {
        show_id: string;
        archive_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Permanently Delete Archived
   * @description Permanently delete an archived item.
   *
   * This cannot be undone - the item and its centroid will be gone forever.
   */
  permanently_delete_archived_archive_shows__show_id___archive_id__delete: {
    parameters: {
      path: {
        show_id: string;
        archive_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Archived Centroids
   * @description Get all archived centroids for matching.
   *
   * Returns list of archived items with their centroid embeddings.
   * Used for auto-archiving matching faces in future episodes.
   */
  get_archived_centroids_archive_shows__show_id__centroids_get: {
    parameters: {
      query?: {
        /** @description Filter: person, cluster, track */
        item_type?: string | null;
      };
      path: {
        show_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Archive Track
   * @description Archive a track before deletion.
   *
   * Stores the track metadata for potential future matching or restoration.
   */
  archive_track_archive_shows__show_id__tracks_post: {
    parameters: {
      path: {
        show_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ArchiveTrackRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List Local Jobs
   * @description List running local jobs (not Celery).
   *
   * These are subprocess jobs running on the local machine, detected either
   * from our registry or by scanning for episode_run.py processes.
   *
   * Args:
   *     ep_id: Optional filter by episode ID
   */
  list_local_jobs_celery_jobs_local_get: {
    parameters: {
      query?: {
        ep_id?: string | null;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Operation Logs
   * @description Get the most recent logs for an operation.
   *
   * This endpoint returns the last saved logs for a given episode and operation.
   * Logs are persisted when local mode jobs complete (success, error, or cancelled).
   *
   * Args:
   *     ep_id: Episode identifier
   *     operation: Operation name (detect_track, faces_embed, cluster)
   *
   * Returns:
   *     - status: "completed" | "error" | "cancelled" | "timeout" | "none"
   *     - logs: List of log lines (empty if status is "none")
   *     - elapsed_seconds: Runtime in seconds
   *     - updated_at: ISO timestamp of when logs were saved
   */
  get_operation_logs_celery_jobs_logs__ep_id___operation__get: {
    parameters: {
      path: {
        ep_id: string;
        operation: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Celery Job Status
   * @description Get status of a Celery background job.
   *
   * This endpoint returns status of jobs submitted via Redis/Celery mode.
   * Local mode jobs are synchronous and do not use this endpoint.
   *
   * Returns:
   *     - job_id: The job ID
   *     - state: Simplified state (queued, in_progress, success, failed, cancelled)
   *     - raw_state: Original Celery state
   *     - result: Job result if completed (success or failure)
   *     - progress: Progress metadata if job is running
   */
  get_celery_job_status_celery_jobs__job_id__get: {
    parameters: {
      path: {
        job_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Cancel Celery Job
   * @description Cancel a running Celery or local background job.
   *
   * Supports:
   * - Celery jobs: Sends revoke signal
   * - Local jobs (orphan-{pid}, local-{ep_id}-{operation}): Kills process by PID
   *
   * Note: This sends a termination signal. Long-running operations may take
   * a moment to actually stop.
   */
  cancel_celery_job_celery_jobs__job_id__cancel_post: {
    parameters: {
      path: {
        job_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Kill All Local Jobs
   * @description Kill all local/orphan jobs, optionally filtered by episode.
   *
   * This is useful for cleaning up stale processes that weren't properly
   * terminated (e.g., after a crash or page refresh).
   *
   * Args:
   *     ep_id: Optional episode ID to filter jobs. If not provided, kills all local jobs.
   *
   * Returns:
   *     List of killed job IDs and their status.
   */
  kill_all_local_jobs_celery_jobs_kill_all_local_post: {
    parameters: {
      query?: {
        ep_id?: string | null;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List Active Celery Jobs
   * @description List currently active Celery jobs.
   *
   * Note: This only shows jobs known to the current worker.
   * Completed jobs are available via their individual job_id.
   *
   * Each job now includes ep_id and operation for matching after page reload.
   */
  list_active_celery_jobs_celery_jobs_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  /**
   * Start Detect Track Celery
   * @description Start a detect/track job.
   *
   * Execution Mode:
   *     - execution_mode="redis" (default): Enqueues job via Celery, returns 202 with job_id
   *     - execution_mode="local": Runs job synchronously in-process, returns result when done
   *
   * Thermal Safety:
   *     - Resolves profile based on device (low_power for CPU/CoreML/MPS)
   *     - Auto-downgrades "performance" profile on non-CUDA devices
   *     - Always applies CPU thread limits (default: 2 for laptops)
   *
   * Check for active jobs before starting to prevent duplicate runs.
   */
  start_detect_track_celery_celery_jobs_detect_track_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DetectTrackCeleryRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Start Faces Embed Celery
   * @description Start a faces embed (harvest) job.
   *
   * Execution Mode:
   *     - execution_mode="redis" (default): Enqueues job via Celery, returns 202 with job_id
   *     - execution_mode="local": Runs job synchronously in-process, returns result when done
   *
   * Thermal Safety:
   *     - Applies CPU thread limits for laptop-friendly operation
   */
  start_faces_embed_celery_celery_jobs_faces_embed_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["FacesEmbedCeleryRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Start Cluster Celery
   * @description Start a clustering job.
   *
   * Execution Mode:
   *     - execution_mode="redis" (default): Enqueues job via Celery, returns 202 with job_id
   *     - execution_mode="local": Runs job synchronously in-process, returns result when done
   *
   * Thermal Safety:
   *     - Applies CPU thread limits for laptop-friendly operation
   */
  start_cluster_celery_celery_jobs_cluster_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ClusterCeleryRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Start Parallel Jobs
   * @description Start the same operation on multiple episodes in parallel.
   *
   * Uses Celery group to execute jobs concurrently across episodes.
   * Returns a group_id that can be used to track overall progress.
   *
   * Args:
   *     episode_ids: List of episode IDs to process
   *     operation: Operation to run (auto_group, refresh_similarity, manual_assign)
   *     options: Options to pass to each task
   *
   * Returns:
   *     - group_id: ID to track the parallel job group
   *     - job_ids: Map of episode_id to individual job_id
   *     - status: "queued" or "error"
   */
  start_parallel_jobs_celery_jobs_parallel_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ParallelJobRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Parallel Job Status
   * @description Get status of a parallel job group.
   *
   * Returns overall progress and per-episode results.
   *
   * Args:
   *     group_id: The group ID returned from /parallel endpoint
   *
   * Returns:
   *     - status: overall status (in_progress, success, partial_success, failed)
   *     - progress: fraction complete (0.0 to 1.0)
   *     - completed: number of completed jobs
   *     - failed: number of failed jobs
   *     - results: per-episode job status
   */
  get_parallel_job_status_celery_jobs_parallel__group_id__get: {
    parameters: {
      path: {
        group_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Job History Endpoint
   * @description Get job history for a user.
   *
   * Returns list of recent jobs with status and timing information.
   *
   * Args:
   *     user_id: User identifier (defaults to "anonymous")
   *     limit: Maximum number of records (default 20)
   *     offset: Number of records to skip (for pagination)
   *
   * Returns:
   *     List of job records, newest first
   */
  get_job_history_endpoint_celery_jobs_history_get: {
    parameters: {
      query?: {
        user_id?: string | null;
        limit?: number;
        offset?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get Active Jobs Endpoint
   * @description Get all active (queued/in_progress) jobs for a user.
   *
   * This is useful for the "My Jobs" panel to show what's currently running.
   *
   * Args:
   *     user_id: User identifier (defaults to "anonymous")
   *
   * Returns:
   *     List of active job records with current status
   */
  get_active_jobs_endpoint_celery_jobs_active_get: {
    parameters: {
      query?: {
        user_id?: string | null;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Health */
  health_health_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
    };
  };
  /**
   * Healthz
   * @description Lightweight health check - must not block on heavy imports or GIL-holding operations.
   */
  healthz_healthz_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
    };
  };
}
