# B4: Skip Unchanged Frames in TrackRecorder
# Reduces redundant track accumulator updates when bbox hasn't changed significantly

## STEP 1: Add Last Recorded State Tracking
### Location: tools/episode_run.py, line ~1959-1971 (TrackRecorder.__init__)

### BEFORE:
```python
    def __init__(self, *, max_gap: int, remap_ids: bool) -> None:
        self.max_gap = max(1, int(max_gap))
        self.remap_ids = remap_ids
        self._next_export_id = 1
        self._mapping: dict[int, dict[str, int]] = {}
        self._active_exports: set[int] = set()
        self._accumulators: dict[int, TrackAccumulator] = {}
        self.metrics = {
            "tracks_born": 0,
            "tracks_lost": 0,
            "id_switches": 0,
            "forced_splits": 0,
        }
```

### AFTER:
```python
    def __init__(self, *, max_gap: int, remap_ids: bool) -> None:
        self.max_gap = max(1, int(max_gap))
        self.remap_ids = remap_ids
        self._next_export_id = 1
        self._mapping: dict[int, dict[str, int]] = {}
        self._active_exports: set[int] = set()
        self._accumulators: dict[int, TrackAccumulator] = {}
        self._last_recorded: dict[int, dict] = {}  # B4: Track last recorded state per tracker_track_id
        self.metrics = {
            "tracks_born": 0,
            "tracks_lost": 0,
            "id_switches": 0,
            "forced_splits": 0,
            "updates_skipped": 0,  # B4: Track how many redundant updates we skipped
        }
```

## STEP 2: Add skip_if_unchanged Parameter
### Location: tools/episode_run.py, line ~1985-1996 (TrackRecorder.record signature)

### BEFORE:
```python
    def record(
        self,
        *,
        tracker_track_id: int,
        frame_idx: int,
        ts: float,
        bbox: list[float] | np.ndarray,
        class_label: int | str,
        landmarks: list[float] | None = None,
        confidence: float | None = None,
        force_new_track: bool = False,
    ) -> int:
```

### AFTER:
```python
    def record(
        self,
        *,
        tracker_track_id: int,
        frame_idx: int,
        ts: float,
        bbox: list[float] | np.ndarray,
        class_label: int | str,
        landmarks: list[float] | None = None,
        confidence: float | None = None,
        force_new_track: bool = False,
        skip_if_unchanged: bool = False,  # B4: New parameter for lightweight updates
    ) -> int:
```

## STEP 3: Add Early Return Logic
### Location: tools/episode_run.py, line ~1997-2001 (beginning of record method, after bbox conversion)

### BEFORE:
```python
        if isinstance(bbox, np.ndarray):
            bbox_values = bbox.tolist()
        else:
            bbox_values = bbox
        export_id: int
        mapping = self._mapping.get(tracker_track_id)
```

### AFTER:
```python
        if isinstance(bbox, np.ndarray):
            bbox_values = bbox.tolist()
        else:
            bbox_values = bbox

        # B4: Skip update if bbox hasn't changed significantly (for lightweight continuity updates)
        if skip_if_unchanged and tracker_track_id in self._last_recorded:
            last = self._last_recorded[tracker_track_id]
            frame_gap = frame_idx - last["frame_idx"]

            # Only check recent frames (within 5 frames)
            if frame_gap < 5:
                # Use numpy allclose for bbox similarity (5% relative tolerance)
                bbox_similar = np.allclose(bbox_values, last["bbox"], rtol=0.05)
                if bbox_similar:
                    self.metrics["updates_skipped"] += 1
                    return last["export_id"]  # Return existing ID without update

        export_id: int
        mapping = self._mapping.get(tracker_track_id)
```

## STEP 4: Update Last Recorded State
### Location: tools/episode_run.py, line ~2039-2040 (end of record method, after track.add)

### BEFORE:
```python
        track.add(ts, frame_idx, bbox_values, confidence=confidence, landmarks=landmarks)
        return export_id
```

### AFTER:
```python
        track.add(ts, frame_idx, bbox_values, confidence=confidence, landmarks=landmarks)

        # B4: Update last recorded state for skip_if_unchanged checks
        self._last_recorded[tracker_track_id] = {
            "frame_idx": frame_idx,
            "bbox": bbox_values,
            "export_id": export_id,
        }

        return export_id
```

## STEP 5: Clear State on Cut
### Location: tools/episode_run.py, line ~2047-2058 (TrackRecorder.on_cut method)

### BEFORE:
```python
    def on_cut(self, frame_idx: int | None = None) -> None:
        """Force-complete all active exports so new IDs spawn after a hard cut."""

        if not self._mapping:
            return
        forced = 0
        for mapping in list(self._mapping.values()):
            self._complete_track(mapping["export_id"])
            forced += 1
        self._mapping.clear()
        if forced:
            self.metrics["forced_splits"] += forced
```

### AFTER:
```python
    def on_cut(self, frame_idx: int | None = None) -> None:
        """Force-complete all active exports so new IDs spawn after a hard cut."""

        if not self._mapping:
            return
        forced = 0
        for mapping in list(self._mapping.values()):
            self._complete_track(mapping["export_id"])
            forced += 1
        self._mapping.clear()
        self._last_recorded.clear()  # B4: Clear cached state on scene cuts
        if forced:
            self.metrics["forced_splits"] += forced
```

## STEP 6: Use in Lightweight Updates
### Location: tools/episode_run.py, line ~3786-3797 (track processing skip logic)

### BEFORE:
```python
                if obj_idx % TRACK_PROCESS_SKIP != 0:
                    # Lightweight continuity update only
                    recorder.record(
                        tracker_track_id=obj.track_id,
                        frame_idx=frame_idx,
                        ts=ts,
                        bbox=obj.bbox,
                        class_label=FACE_CLASS_LABEL,
                        landmarks=None,
                        confidence=float(obj.conf) if obj.conf is not None else None,
                        force_new_track=False,
                    )
                    continue
```

### AFTER:
```python
                if obj_idx % TRACK_PROCESS_SKIP != 0:
                    # Lightweight continuity update only
                    recorder.record(
                        tracker_track_id=obj.track_id,
                        frame_idx=frame_idx,
                        ts=ts,
                        bbox=obj.bbox,
                        class_label=FACE_CLASS_LABEL,
                        landmarks=None,
                        confidence=float(obj.conf) if obj.conf is not None else None,
                        force_new_track=False,
                        skip_if_unchanged=True,  # B4: Skip if bbox hasn't changed
                    )
                    continue
```

## Key Changes:
1. Track last recorded bbox/frame for each tracker_track_id
2. Add `skip_if_unchanged` parameter to record() method
3. Check bbox similarity using np.allclose (5% tolerance) before adding update
4. Return early with existing export_id if bbox unchanged within 5 frames
5. Clear cached state on scene cuts to prevent stale comparisons
6. Track "updates_skipped" metric for diagnostics

## Impact:
- Further reduces redundant track accumulator updates
- Estimated ~10% CPU savings from fewer list appends/memory operations
- Estimated ~20% memory savings by not storing duplicate bbox samples
- Works synergistically with B2 (TRACK_PROCESS_SKIP) optimization

## Expected Behavior:
- For lightweight continuity updates (skipped tracks), only record if bbox moved >5%
- For full processing updates (sampled tracks), always record (skip_if_unchanged=False)
- Prevents track.add() calls when track is stationary between sampled frames

## Metrics:
After running, check `track_metrics.json` for:
```json
{
  "tracks_born": 3000,
  "tracks_lost": 3000,
  "id_switches": 50,
  "forced_splits": 120,
  "updates_skipped": 25000  // B4: Number of redundant updates avoided
}
```

## Testing:
```bash
python tools/episode_run.py \
  --ep-id "TEST-B4" \
  --video path/to/episode.mp4 \
  --stride 6 \
  --save-crops \
  --device auto

# Check metrics
cat data/episodes/TEST-B4/manifests/track_metrics.json | jq '.updates_skipped'
```

## Tuning:
- **rtol=0.05**: 5% relative tolerance (default) - good balance
- **rtol=0.02**: 2% tolerance - more sensitive to small movements
- **rtol=0.10**: 10% tolerance - more aggressive skipping
- **frame_gap < 5**: Only check recent frames (prevents stale comparisons)
